{"version":3,"names":[],"mappings":"","sources":["angular-es7-integration.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Abstract = exports.Schedule = exports.Debounce = exports.On = exports.WatchCollection = exports.Watch = exports.Destroy = exports.Init = exports.Inject = exports.State = exports.Self = exports.Alias = exports.View = exports.Run = exports.Config = exports.Filter = exports.Bind = exports.Component = exports.Directive = exports.Service = exports.Controller = exports.config = undefined;\n\nvar _Configuration = require(\"./util/Configuration\");\n\nvar _Controller = require(\"./decorators/Controller\");\n\nvar _Service = require(\"./decorators/Service\");\n\nvar _Directive = require(\"./decorators/Directive\");\n\nvar _Component = require(\"./decorators/Component\");\n\nvar _Filter = require(\"./decorators/Filter\");\n\nvar _Config = require(\"./decorators/Config\");\n\nvar _Run = require(\"./decorators/Run\");\n\nvar _View = require(\"./decorators/View\");\n\nvar _Alias = require(\"./decorators/Alias\");\n\nvar _Self = require(\"./decorators/Self\");\n\nvar _State = require(\"./decorators/State\");\n\nvar _Inject = require(\"./decorators/Inject\");\n\nvar _MethodDecorators = require(\"./decorators/MethodDecorators\");\n\nexports.config = _Configuration.config;\n\n//Export decorators\n//Export config\n\nexports.Controller = _Controller.Controller;\nexports.Service = _Service.Service;\nexports.Directive = _Directive.Directive;\nexports.Component = _Component.Component;\nexports.Bind = _Component.Bind;\nexports.Filter = _Filter.Filter;\nexports.Config = _Config.Config;\nexports.Run = _Run.Run;\nexports.View = _View.View;\nexports.Alias = _Alias.Alias;\nexports.Self = _Self.Self;\nexports.State = _State.State;\nexports.Inject = _Inject.Inject;\nexports.Init = _MethodDecorators.Init;\nexports.Destroy = _MethodDecorators.Destroy;\nexports.Watch = _MethodDecorators.Watch;\nexports.WatchCollection = _MethodDecorators.WatchCollection;\nexports.On = _MethodDecorators.On;\nexports.Debounce = _MethodDecorators.Debounce;\nexports.Schedule = _MethodDecorators.Schedule;\nexports.Abstract = _MethodDecorators.Abstract;\n\n},{\"./decorators/Alias\":2,\"./decorators/Component\":3,\"./decorators/Config\":4,\"./decorators/Controller\":5,\"./decorators/Directive\":6,\"./decorators/Filter\":7,\"./decorators/Inject\":8,\"./decorators/MethodDecorators\":9,\"./decorators/Run\":10,\"./decorators/Self\":11,\"./decorators/Service\":12,\"./decorators/State\":13,\"./decorators/View\":14,\"./util/Configuration\":17}],2:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Alias = Alias;\n/**\r\n * Sets the alias for a controller, can only be used together with @State\r\n * and @Component\r\n * @decorator\r\n */\nfunction Alias(alias) {\n    return function (target, name) {\n        (target[name] || target).$$alias = alias;\n        return target;\n    };\n}\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Component = Component;\nexports.Bind = Bind;\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\nvar _AngularUtils = require(\"../util/AngularUtils\");\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * Defines the class as Component\r\n *\r\n * A component is typically restricted to \"E\" => Element, meaning it will look like\r\n * <component></component> in html.\r\n *\r\n * You can configure the decorator either just with the component selector as string, or\r\n * with a typical angular directive config object, there are some shortcuts available:\r\n *  - controllerAs => as\r\n *  - scope => bind\r\n *  - template => view\r\n *\r\n *  A Component doesn't use the scope, but binds all properties to the controller directly instead.\r\n *\r\n *  If you're using class properties you can use the @Bind([type]) decorator to directly indicate the\r\n *  attributes that should be bound to the outer scope\r\n *\r\n * The @Component decorator can be used together with @View and @Alias and @Bind!\r\n *\r\n * @decorator\r\n * @param conf\r\n * @exports\r\n */\nfunction Component() {\n    var conf = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    if (conf.constructor == String) {\n        conf = { selector: conf };\n    }\n    conf.controllerAs = conf.as || conf.controllerAs;\n    conf.restrict = conf.restrict || \"E\";\n    if (conf.bind == false) conf.bind = false;else conf.bind = conf.bind || {};\n\n    conf.template = conf.view || conf.template;\n    conf.selector = conf.name || conf.selector;\n\n    return function (target) {\n        conf.controller = target;\n        App.directive(conf.selector, function () {\n\n            //Merge @Bind properties\n            if (conf.bind !== false) {\n                conf.bind = Object.assign(conf.bind || {}, target.$$bind || {});\n            }\n\n            conf.controllerAs = target.$$alias || conf.controllerAs || \"$ctrl\";\n            conf.bindToController = conf.bind;\n\n            (0, _AngularUtils.decorateView)(target, conf);\n\n            return conf;\n        });\n    };\n}\n\n/**\r\n * Defines a class property as bound attribute\r\n * @decorator\r\n * @param bindType = or & or @\r\n * @param [attributeName] the name of the attribute, defaults to the property name\r\n * @return {function(*, *, *)}\r\n */\nfunction Bind(bindType, attributeName) {\n    return function (target, name, desc) {\n\n        //Set default attribute name\n        if (!attributeName) attributeName = name;\n\n        //Add the bind property to the type\n        var type = target.constructor;\n        type.$$bind = type.$$bind || {};\n        type.$$bind[name] = bindType + attributeName;\n\n        return {\n            writable: true,\n            value: desc.value\n        };\n    };\n}\n\n},{\"../util/AngularModuleResolver\":15,\"../util/AngularUtils\":16}],4:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Config = Config;\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\nvar _AngularUtils = require(\"../util/AngularUtils\");\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * Defines a method as config block\r\n * @decorator\r\n * @exports\r\n */\nfunction Config(target, name) {\n  target = (0, _AngularUtils.fetch)(target);\n  if (target instanceof Function) App.config(target);else App.config(target[name]);\n}\n\n},{\"../util/AngularModuleResolver\":15,\"../util/AngularUtils\":16}],5:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Controller = Controller;\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\nvar _AngularUtils = require(\"../util/AngularUtils\");\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * Defines a class as Controller, if no name is provided aka the decorator is\r\n * used as @Controller then the class name is used as controller name, you can\r\n * specify the name by using the decorator like @Controller(\"ControllerName\") to\r\n * make the decorator minify safe\r\n *\r\n * @decorator\r\n * @param {string | function} [clazz]\r\n */\nfunction Controller(clazz) {\n    clazz = (0, _AngularUtils.fetch)(clazz);\n\n    //Function to add the controller\n    var addController = function addController(name, clazz) {\n        return App.controller(name, clazz);\n    };\n\n    if (clazz instanceof Function) {\n        addController(clazz.name, clazz);\n    } else return function (target) {\n        addController(clazz, target);\n    };\n}\n\n},{\"../util/AngularModuleResolver\":15,\"../util/AngularUtils\":16}],6:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Directive = Directive;\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\nvar _AngularUtils = require(\"../util/AngularUtils\");\n\nvar _ES6Directive = require(\"../util/ES6Directive\");\n\nvar _ES6Directive2 = _interopRequireDefault(_ES6Directive);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * Defines a class or a class method as Directive, if no name is provided aka the decorator is\r\n * used as @Directive then the class name or the method name is used as directive name, you can\r\n * specify the name by using the decorator like @Directive(\"myDirectiy\") to\r\n * make the decorator minify safe\r\n *\r\n * @decorator\r\n * @param {string | function} clazz\r\n * @param {string} [name]\r\n * @returns {Function}\r\n * @exports\r\n */\nfunction Directive(clazz, name) {\n    clazz = (0, _AngularUtils.fetch)(clazz);\n\n    var registerDirective = function registerDirective(name, fn) {\n        return App.directive(name, (0, _ES6Directive2.default)(fn));\n    };\n\n    if (clazz.constructor != String) //Directive is called without name => @Directive\n        {\n            if (clazz instanceof Function) registerDirective(clazz.name, clazz); //Class\n            else registerDirective(name, clazz[name]); //Class method\n        } else return function (target, n) {\n        //Directive is called without name => @Directive(\"myDirective\")\n        if (target instanceof Function) registerDirective(clazz, target); //Class\n        else registerDirective(n, target[n]); //Class method\n    };\n}\n\n},{\"../util/AngularModuleResolver\":15,\"../util/AngularUtils\":16,\"../util/ES6Directive\":18}],7:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Filter = Filter;\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\nvar _AngularUtils = require(\"../util/AngularUtils\");\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * REgisters a method as an angular Filter\r\n * If used like @Filter the method name will be chosen as filter name,\r\n * Alternatively you can give the filter name as argument, your method will then look\r\n * like @Filter(\"myFilter\")...\r\n * @decorator\r\n * @exports\r\n */\nfunction Filter(clazz, method) {\n    clazz = (0, _AngularUtils.fetch)(clazz);\n\n    //Function to add the controller\n    var registerFilter = function registerFilter(name, fn) {\n        return App.filter(name, fn);\n    };\n\n    if (clazz.constructor != String) {\n        //With method name as filter name\n        registerFilter(method, clazz[method]);\n    } else return function (target, method) {\n        //With specified name\n        registerFilter(clazz, target[method]);\n    };\n}\n\n},{\"../util/AngularModuleResolver\":15,\"../util/AngularUtils\":16}],8:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.Inject = Inject;\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\nvar _AngularUtils = require(\"../util/AngularUtils\");\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * Inject one of the following into the object:\r\n *      - services\r\n *      - $scope\r\n *      - any $scope variable\r\n *\r\n * the variable: usage =>\r\n * class foo {\r\n *      @Inject $timeout;\r\n *      @Inject(\"$timeout\") tmout;\r\n *      @Inject fooCtrl\r\n *      @Inject scopeVar\r\n *      @Inject $scope\r\n *\r\n *      constructor()\r\n *      {\r\n *          console.log(this.$timeout, this.tmout);\r\n *      }\r\n * }\r\n *\r\n * Attention! The property won't get injected instantly, but a getter\r\n * which will replace itself with the resolved object on the first call,\r\n * with this technique we're able to resolve circular dependencies sometimes\r\n *\r\n * @param target\r\n * @param name\r\n * @param descriptor\r\n * @decorator\r\n */\nfunction Inject(target, name, descriptor) {\n    var fieldName = void 0;\n    var injector = function injector(target, name, descriptor) {\n        if (descriptor.value instanceof Function) {\n            throw new Error(\"Can't use @Inject on a method\");\n        }\n\n        return {\n            set: function set(value) {\n                Object.defineProperty(this, fieldName, { value: value, writable: true });\n            },\n            get: function get() {\n\n                var $injector = (0, _AngularModuleResolver.angularInjector)();\n                var obj = null;\n                var injected = false;\n\n                var locals = this.$$locals || currentLocals;\n\n                //Locale\n                if (locals && (locals.hasOwnProperty(name) || locals[name])) {\n                    obj = locals[name];\n                    injected = true;\n                }\n\n                //Service\n                else if ($injector.has(name)) {\n                        obj = $injector.get(name);\n                        injected = true;\n                    }\n\n                    //$scope or parent scope property\n                    else if (locals && locals.$scope && (Reflect.hasOwnProperty(locals.$scope, name) || locals.$scope[name])) {\n                            obj = locals.$scope[name];\n                            injected = true;\n                        }\n\n                if (!injected) {\n                    console.error(\"Wasn't able to @Inject \" + name + \" as \" + fieldName + \" into \" + target.constructor.name);\n                    return;\n                }\n\n                Object.defineProperty(this, fieldName, { value: obj, writable: true });\n                return obj;\n            }\n        };\n    };\n\n    if (descriptor) {\n        fieldName = name;\n        return injector(target, name, descriptor);\n    } else {\n        var _ret = function () {\n            var nameReplacement = target;\n            return {\n                v: function v(target, name, descriptor) {\n                    fieldName = name;\n                    return injector(target, nameReplacement, descriptor);\n                }\n            };\n        }();\n\n        if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n}\n\nvar currentLocals = undefined;\nApp.config(function ($provide) {\n    $provide.decorator(\"$controller\", function ($delegate) {\n        return function (expression, locals, later, ident) {\n\n            //For usage in constructor\n            currentLocals = locals;\n\n            //Create the controller\n            var controller = $delegate(expression, locals, later, ident);\n\n            //Reset the locals\n            currentLocals = undefined;\n\n            //Check if its an object\n            if (!later) {\n                controller.$$locals = locals;\n                controller.$$scope = locals.$scope;\n                (0, _AngularUtils.callAnnotations)(controller, locals.$scope);\n                return controller;\n            } else {\n                return function () {\n                    currentLocals = locals;\n                    var c = controller();\n                    currentLocals = undefined;\n                    c.$$locals = locals;\n                    c.$$scope = locals.$scope;\n                    (0, _AngularUtils.callAnnotations)(c, locals.$scope);\n                    return c;\n                };\n            }\n        };\n    });\n});\n\n},{\"../util/AngularModuleResolver\":15,\"../util/AngularUtils\":16}],9:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Init = Init;\nexports.Destroy = Destroy;\nexports.Watch = Watch;\nexports.WatchCollection = WatchCollection;\nexports.Schedule = Schedule;\nexports.On = On;\nexports.Debounce = Debounce;\nexports.Abstract = Abstract;\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\n/**\r\n * Executes all Methods annotated with this annotation after\r\n * the object has been created\r\n *\r\n * Only working in services and controllers!\r\n *\r\n * @decorator\r\n */\nfunction Init(target, name, descriptor) {\n    if (!descriptor) {\n        throw new Error(\"@Init can only be used on class methods\");\n    }\n    target.$$init = target.$$init || new Set();\n    target.$$init.add(name);\n}\n\n/**\r\n * Executes all Methods annotated with this annotation after\r\n * the object gets destroyed.\r\n *\r\n * Only usable in controllers!\r\n *\r\n * @param target\r\n * @param name\r\n * @exports\r\n * @decorator\r\n */\nfunction Destroy(target, name) {\n    target.$$destroy = target.$$destroy || new Set();\n    target.$$destroy.add(name);\n}\n\n/**\r\n * Sets a $watch on the given controller evaluation, the method will be used\r\n * as regular $watch callback.\r\n *\r\n * If your controller has a property \"foo\" the following method would watch for\r\n * changes on \"foo\"\r\n *\r\n * \\@Watch(\"foo\")\r\n * fooChanged(newVal, oldVal)\r\n * {\r\n *  ........\r\n * }\r\n *\r\n * @param property\r\n * @param {boolean} [deep]\r\n * @exports\r\n * @decorator\r\n */\nfunction Watch(property) {\n    var deep = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n\n    return function (target, name) {\n        target.$$watch = target.$$watch || new Set();\n        target.$$watch.add({ property: property, name: name, deep: deep, collection: false });\n    };\n}\n\n/**\r\n * Same as @Watch but for collections\r\n * @param [property]\r\n * @exports\r\n * @decorator\r\n */\nfunction WatchCollection(property) {\n\n    return function (target, name) {\n        target.$$watch = target.$$watch || new Set();\n        target.$$watch.add({ property: property, name: name, false: false, collection: true });\n    };\n}\n\n/**\r\n * Schedules the method so it will get executed every n milliseconds\r\n * @param interval in milliseconds\r\n * @decorator\r\n */\nfunction Schedule(interval) {\n    return function (target, name, desc) {\n        target.$$schedule = target.$$schedule || new Set();\n        target.$$schedule.add({ interval: interval, name: name });\n    };\n}\n\n/**\r\n * Registers the method as an eventhandler via $scope.$on\r\n *\r\n * \\@On(\"$stateChangeSucces\")\r\n * stateChanged(newState, oldState ...)\r\n * {\r\n *  .......\r\n * }\r\n *\r\n * @param event\r\n * @decorator\r\n */\nfunction On(event) {\n    return function (target, name, desc) {\n        target.$$on = target.$$on || new Set();\n        target.$$on.add({ event: event, name: name });\n    };\n}\n\n/**\r\n * Debounces the method so it will only get executed after it hasn't been called\r\n * for n millis\r\n *\r\n * @param millis\r\n * @param {boolean} [angularTimeout=true] - if false the window timeout will get used\r\n * @returns {Function}\r\n * @decorator\r\n */\nfunction Debounce(millis) {\n    var angularTimeout = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n    return function (target, name, desc) {\n        var timeout = void 0;\n        var fn = desc.value;\n        desc.value = function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            //Setup\n            var context = this;\n            var timeoutFn = function timeoutFn() {\n                fn.apply(context, args);\n            };\n\n            //Use angular $timeout ($apply cycle)\n            if (angularTimeout) {\n                var $timeout = (0, _AngularModuleResolver.angularInjector)().get(\"$timeout\");\n                $timeout.cancel(timeout);\n                timeout = $timeout(timeoutFn, millis);\n            }\n            //Use window timeout\n            else {\n                    clearTimeout(timeout);\n                    timeout = setTimeout(timeoutFn, millis);\n                }\n        };\n    };\n}\n\n/**\r\n * Marks a method as abstract, this means the method will get replaced\r\n * with one that throws an error when called saying the method\r\n * is not implemented\r\n * @param target\r\n * @param name\r\n * @param desc\r\n * @decorator\r\n */\nfunction Abstract(target, name, desc) {\n    desc.value = function () {\n        throw new Error(target.name + \"@\" + name + \" is not implemented (Abstract)\");\n    };\n}\n\n},{\"../util/AngularModuleResolver\":15}],10:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Run = Run;\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\nvar _AngularUtils = require(\"../util/AngularUtils\");\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * Defines a method as run block\r\n * @decorator\r\n * @exports\r\n */\nfunction Run(target, name) {\n  target = (0, _AngularUtils.fetch)(target);\n  if (target instanceof Function) App.run(target);else App.run(target[name]);\n}\n\n},{\"../util/AngularModuleResolver\":15,\"../util/AngularUtils\":16}],11:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.Self = Self;\n/**\r\n * The decorator may be used on classes or methods\r\n * ```\r\n * @Self\r\n * class FullBound {}\r\n *\r\n * class PartBound {\r\n *   @Self\r\n *   method () {}\r\n * }\r\n * ```\r\n *\r\n * @decorator\r\n */\nfunction Self() {\n    if (arguments.length === 1) {\n        return boundClass.apply(undefined, arguments);\n    } else {\n        return boundMethod.apply(undefined, arguments);\n    }\n}\n\n/**\r\n * Use boundMethod to bind all methods on the target.prototype\r\n */\nfunction boundClass(target) {\n    // (Using reflect to get all keys including symbols)\n    var keys = void 0;\n    // Use Reflect if exists\n    if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\n        keys = Reflect.ownKeys(target.prototype);\n    } else {\n        keys = Object.getOwnPropertyNames(target.prototype);\n        // use symbols if support is provided\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\n        }\n    }\n\n    keys.forEach(function (key) {\n        // Ignore special case target method\n        if (key === 'constructor') {\n            return;\n        }\n\n        var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key);\n\n        // Only methods need binding\n        if (typeof descriptor.value === 'function') {\n            Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\n        }\n    });\n    return target;\n}\n\n/**\r\n * Return a descriptor removing the value and returning a getter\r\n * The getter will return a .bind version of the function\r\n * and memoize the result against a symbol on the instance\r\n */\nfunction boundMethod(target, key, descriptor) {\n    var fn = descriptor.value;\n\n    if (typeof fn !== 'function') {\n        throw new Error('@Self decorator can only be applied to methods not: ' + (typeof fn === 'undefined' ? 'undefined' : _typeof(fn)));\n    }\n\n    return {\n        configurable: true,\n        get: function get() {\n            var self = this;\n            return function () {\n                for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n                    params[_key] = arguments[_key];\n                }\n\n                return fn.call.apply(fn, [self].concat(params));\n            };\n        }\n    };\n}\n\n},{}],12:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Service = Service;\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\nvar _AngularUtils = require(\"../util/AngularUtils\");\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * Defines a class as Service, if no name is provided aka the decorator is\r\n * used as @Service then the class name is used as service name, you can\r\n * specify the name by using the decorator like @Service(\"ServiceName\") to\r\n * make the decorator minify safe\r\n *\r\n * @decorator\r\n * @param {string | function} [clazz]\r\n */\nfunction Service(clazz) {\n    clazz = (0, _AngularUtils.fetch)(clazz);\n\n    //Function to add the controller\n    var addService = function addService(name, clazz) {\n        return App.service(name, clazz);\n    };\n\n    if (clazz instanceof Function) {\n        addService(clazz.name, clazz);\n    } else return function (target) {\n        addService(clazz, target);\n    };\n}\n\n},{\"../util/AngularModuleResolver\":15,\"../util/AngularUtils\":16}],13:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.State = State;\n\nvar _Controller = require(\"./Controller\");\n\nvar _AngularModuleResolver = require(\"../util/AngularModuleResolver\");\n\nvar _AngularUtils = require(\"../util/AngularUtils\");\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * Angular UI Router support\r\n *\r\n * With this Decorator you are able to decorate any class with @State,\r\n * as parameter you will give the usual state config\r\n *\r\n * In addition you can specify a default state by adding default : true\r\n * to the state config, this state will be called when a 404 aka a missing\r\n * url is requested. You're also able to shorten controllerAS to as.\r\n *\r\n * The class which is being decorated with @State will work as controller\r\n * for the specified state\r\n *\r\n * The State decorator works best with @Alias and @View\r\n *\r\n * @decorator\r\n * @param conf\r\n * @returns {Function}\r\n * @exports\r\n */\nfunction State(conf) {\n    return function (target) {\n        target.$$state = conf;\n        (0, _Controller.Controller)(target);\n        return target;\n    };\n}\n\n/**\r\n * Tries to configure the state from the $$state var on\r\n * the all controllers\r\n * @param clazz\r\n */\nApp.config(function ($urlRouterProvider, $injector) {\n    \"ngInject\";\n\n    var registeredControllers = [];\n    var states = [];\n\n    //Find every state controller\n    App._invokeQueue.forEach(function (item) {\n        var constructor = item[2][1];\n        if (registeredControllers.find(function (t) {\n            return t.type == constructor;\n        })) return;\n        if (constructor.$$state) {\n            constructor.$$state.clazz = constructor;\n            states.push(constructor.$$state);\n            registeredControllers.push({ type: constructor });\n        }\n    });\n\n    //Return if ui-router is not installed\n    if (!$injector.has(\"$stateProvider\")) {\n\n        if (states.length) {\n            console.error(\"Error: @State is used but ui-router is not installed!\");\n        }\n        return;\n    }\n\n    //Fetch the state provider\n    var $stateProvider = $injector.get(\"$stateProvider\");\n\n    //Configure all states\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        var _loop = function _loop() {\n            var conf = _step.value;\n\n            var clazz = conf.clazz;\n\n            /*\r\n             * Default state\r\n             */\n            if (conf.default) {\n                $urlRouterProvider.otherwise(function ($injector) {\n                    $injector.invoke(['$state', function ($state) {\n                        $state.go(conf.name, {}, { location: \"replace\" });\n                    }]);\n                });\n            }\n\n            /*\r\n             * Set Controller\r\n             */\n            conf.controller = clazz;\n            conf.controllerAs = conf.as || conf.controllerAs || clazz.$$alias;\n\n            /**\r\n             * Set view\r\n             */\n            (0, _AngularUtils.decorateView)(clazz, conf);\n\n            /*\r\n             * Set the state\r\n             */\n            $stateProvider.state(conf);\n        };\n\n        for (var _iterator = states[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            _loop();\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n});\n\n},{\"../util/AngularModuleResolver\":15,\"../util/AngularUtils\":16,\"./Controller\":5}],14:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.View = View;\n/**\r\n * Sets the view of an @Component or a @State can either be\r\n * a template or a templateUrl, the view is recognized as template\r\n * if it contains at least 1 tag!\r\n * @param view\r\n * @Decorator\r\n */\nfunction View(view) {\n    return function (target) {\n        target.$$view = view;\n        return target;\n    };\n}\n\n},{}],15:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.lookupAngularModule = lookupAngularModule;\nexports.useAngularModule = useAngularModule;\nexports.angularInjector = angularInjector;\n/**\r\n * Reference to the angular module used by Angular2to1, this module is either\r\n * resolved via ng-app or by useAngularModule(...)\r\n */\nvar angularModule = null;\n\n/**\r\n * The injector of our main module\r\n * This $injector service is set as soon as the module was requested\r\n * the first time and angular is beyond its run phase\r\n */\nvar $injector = null;\n\n/**\r\n * Attempts to lookup the root angular module of the app by resolving the first\r\n * ng-app on the DOM\r\n * As an alternative you can set your module with useAngularModule(), which will\r\n * then be returned by this function\r\n */\nfunction lookupAngularModule() {\n    //Returns the preset module if available\n    if (angularModule) {\n        return angularModule;\n    }\n\n    var ngAppHolder = angular.element(\"[ng-app]\");\n\n    if (!ngAppHolder.length) {\n        throw new Error(\"No element with [ng-app] found and no module set with 'useAngularModule()'\");\n    }\n\n    var moduleName = ngAppHolder[0].getAttribute('ng-app');\n    angularModule = angular.module(moduleName);\n    angularModule.run([\"$injector\", function (i) {\n        return $injector = i;\n    }]);\n\n    return angularModule;\n}\n\n/**\r\n * Sets the angular module which is used by Angular2to1\r\n * @param module\r\n */\nfunction useAngularModule(module) {\n    angularModule = module;\n}\n\n/**\r\n * Returns the main $injector of the root angular\r\n * module, is available as soon as the module has been requested at least\r\n * once and angular is beyond its run phase\r\n * @decorator\r\n * @return {*}\r\n */\nfunction angularInjector() {\n    return $injector;\n}\n\n//Attempt to export the module directly\ntry {\n    lookupAngularModule();\n} catch (e) {}\n\n/**\r\n * Export the module, warning, MAY BE UNDEFINED if the module gets\r\n * initiated later, to make sure you get the module use lookupAngularModule\r\n */\nexports.default = angularModule;\n\n},{}],16:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fetch = fetch;\nexports.decorateView = decorateView;\nexports.callAnnotations = callAnnotations;\n\nvar _AngularModuleResolver = require(\"./AngularModuleResolver\");\n\nvar _Configuration = require(\"./Configuration\");\n\nvar App = (0, _AngularModuleResolver.lookupAngularModule)();\n\n/**\r\n * If the argument is an array (inject) this method\r\n * will return only the function with the $inject property\r\n * set\r\n * @param arg\r\n * @returns {Function}\r\n */\nfunction fetch(arg) {\n    if (arg.constructor == Array) {\n        var arr = arg;\n        arg = arr.splice(arr.length - 1, 1)[0];\n        arg.$inject = arr;\n    }\n    return arg;\n}\n\n/**\r\n * Decorates the view to the configuration\r\n * @param clazz\r\n * @param conf\r\n */\nfunction decorateView(clazz, conf) {\n    var view = clazz.$$view;\n    if (!view) return;\n    var urlRegex = /[^<>]+\\.[A-Za-z]{2,5}$/;\n    if (urlRegex.test(view)) {\n        //url\n        conf.templateUrl = view;\n    } else {\n        conf.template = view;\n    }\n}\n\n// Run block which will configure all annotations on any services available\n// All services are used together with the $rootScope\n/**\r\n * Exposes all services of a single module\r\n * @param module\r\n */\nvar exposeModule = function exposeModule(module) {\n    var $injector = (0, _AngularModuleResolver.angularInjector)();\n    var $rootScope = $injector.get(\"$rootScope\");\n    module._invokeQueue.forEach(function (item) {\n        var def = item[2];\n        if ($injector.has(def[0])) {\n            var service = $injector.get(def[0]);\n            callAnnotations(service, $rootScope);\n        }\n    });\n};\nApp.run(function () {\n    if (_Configuration.config.ALLOW_DECORATORS_IN_SERVICES) {\n        exposeModule(App);\n    }\n});\n\n/**\r\n * Calls all registered annotations on the controller, or on\r\n * a service\r\n * @param controller\r\n * @param $scope\r\n */\nfunction callAnnotations(controller, $scope) {\n    //Async wrapper\n    var asyncWrapper = function asyncWrapper(result) {\n        if (result instanceof Promise) {\n            result.then(function () {\n                return $scope.$digest.call($scope);\n            });\n        }\n    };\n\n    //Call init methods\n    var inited = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = (controller.$$init || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var initializer = _step.value;\n\n            if (!inited.includes(initializer)) {\n                asyncWrapper(controller[initializer]());\n            }\n            inited.push(initializer);\n        }\n\n        //Bind watches\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    var watched = [];\n    var $parse = (0, _AngularModuleResolver.angularInjector)().get(\"$parse\");\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        var _loop = function _loop() {\n            var watcher = _step2.value;\n\n            if (!watched.includes(watcher)) {\n                (function () {\n\n                    //Parse the angular expression\n                    var parse = $parse(watcher.property);\n                    var getter = function getter() {\n                        return parse(controller);\n                    };\n\n                    var action = function () {\n                        controller[watcher.name].apply(controller, arguments);\n                    }.bind(controller);\n\n                    if (!watcher.collection) $scope.$watch(getter, action, !!watcher.deep);else $scope.$watchCollection(getter, action);\n                })();\n            }\n            watched.push(watcher);\n        };\n\n        for (var _iterator2 = (controller.$$watch || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            _loop();\n        }\n\n        //Bind events\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n\n    var evented = [];\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n        var _loop2 = function _loop2() {\n            var on = _step3.value;\n\n            if (!evented.includes(on)) {\n                $scope.$on(on.event, function () {\n                    asyncWrapper(controller[on.name].apply(controller, arguments));\n                }).bind(controller);\n            }\n            evented.push(on);\n        };\n\n        for (var _iterator3 = (controller.$$on || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            _loop2();\n        }\n\n        //Scheduled methods\n    } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n            }\n        } finally {\n            if (_didIteratorError3) {\n                throw _iteratorError3;\n            }\n        }\n    }\n\n    var $interval = (0, _AngularModuleResolver.angularInjector)().get(\"$interval\");\n    var scheduled = [];\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n        var _loop3 = function _loop3() {\n            var schedule = _step4.value;\n\n            if (!scheduled.includes(schedule)) {\n                (function () {\n                    var id = $interval(function () {\n                        asyncWrapper(controller[schedule.name]());\n                    }.bind(controller), schedule.interval);\n                    $scope.$on(\"$destroy\", function () {\n                        return $interval.cancel(id);\n                    });\n                })();\n            }\n        };\n\n        for (var _iterator4 = (controller.$$schedule || [])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            _loop3();\n        }\n\n        //Call destroy methods\n    } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                _iterator4.return();\n            }\n        } finally {\n            if (_didIteratorError4) {\n                throw _iteratorError4;\n            }\n        }\n    }\n\n    $scope.$on(\"$destroy\", function () {\n        var destroyed = [];\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n            for (var _iterator5 = (controller.$$destroy || [])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var destroyer = _step5.value;\n\n                if (!destroyed.includes(destroyer)) controller[destroyer]();\n                destroyed.push(destroyer);\n            }\n        } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                    _iterator5.return();\n                }\n            } finally {\n                if (_didIteratorError5) {\n                    throw _iteratorError5;\n                }\n            }\n        }\n    });\n}\n\n},{\"./AngularModuleResolver\":15,\"./Configuration\":17}],17:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// The purpose of this file is to provide an easy configuration API\n// accesible from the outside\n\n/**\r\n * The module configuration, as an anonymous object\r\n */\nvar Angular2to1Config = {\n\n    //PromiseHook configuration\n    DEBOUNCE_DIGEST: false,\n    DEBOUNCE_DIGEST_MILLIS: 25,\n    ASYNC_AWAIT_ENABLED: true,\n\n    //Further configuration\n    ALLOW_DECORATORS_IN_SERVICES: true\n};\n\nexports.config = Angular2to1Config;\n\n},{}],18:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (directive) {\n    /**\r\n     * Fetch function from array\r\n     */\n    if (directive.constructor == Array) {\n        var arr = directive;\n        directive = arr.splice(arr.length - 1, 1)[0];\n        directive.$inject = arr;\n    }\n\n    //Check if directive is an actual class\n    try {\n        directive();\n        return directive;\n    } catch (e) {\n        //Continue and wrap class to make it usable in angular\n        if (!(e instanceof TypeError)) return directive;\n    }\n\n    var fn = function fn() {\n        for (var _len = arguments.length, inject = Array(_len), _key = 0; _key < _len; _key++) {\n            inject[_key] = arguments[_key];\n        }\n\n        //Create Directive\n        var instance = new (Function.prototype.bind.apply(directive, [null].concat(inject)))();\n\n        //Wrap link call to keep this references\n        if (!!instance.link) {\n            (function () {\n                var link = instance.link;\n\n                instance.link = function () {\n                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                        args[_key2] = arguments[_key2];\n                    }\n\n                    link.apply(instance, args);\n                };\n            })();\n        }\n\n        //Wrap compile call to keep \"this\" reference\n        if (!!instance.compile) {\n            (function () {\n                var compile = instance.compile;\n\n                instance.compile = function () {\n                    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                        args[_key3] = arguments[_key3];\n                    }\n\n                    compile.apply(instance, args);\n                };\n            })();\n        }\n\n        //Return the directive to angular\n        return instance;\n    };\n\n    //Kepp ngAnnotate injects\n    fn.$inject = directive.$inject;\n\n    return fn;\n};\n\n; /**\r\n   * This wrapper enables an intuitive way to use of es6 classes\r\n   * as angular directive.\r\n   * If you wrap your directive class with this function you can\r\n   * use link/compile functions with \"this\" reference and @ngInject\r\n   * on both the constructor and the controller!\r\n   *\r\n   * @param directive\r\n   * @returns {fn}\r\n   */\n\n},{}]},{},[1]);\n"],"file":"angular-es7-integration.js","sourceRoot":"/source/"}
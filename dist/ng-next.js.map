{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/process/browser.js","node_modules/zone.js/dist/zone.js","src/NgNext.js","src/decorators/Alias.js","src/decorators/Component.js","src/decorators/Config.js","src/decorators/Controller.js","src/decorators/Directive.js","src/decorators/Filter.js","src/decorators/Inject.js","src/decorators/MethodDecorators.js","src/decorators/Run.js","src/decorators/Self.js","src/decorators/Service.js","src/decorators/State.js","src/decorators/View.js","src/integration/WatchIterableFix.js","src/integration/ZoneJSIntegration.js","src/util/AngularModuleResolver.js","src/util/AngularUtils.js","src/util/Configuration.js","src/util/ES6Directive.js","src/util/Symbols.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"ng-next.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n    try {\n        cachedSetTimeout = setTimeout;\n    } catch (e) {\n        cachedSetTimeout = function () {\n            throw new Error('setTimeout is not defined');\n        }\n    }\n    try {\n        cachedClearTimeout = clearTimeout;\n    } catch (e) {\n        cachedClearTimeout = function () {\n            throw new Error('clearTimeout is not defined');\n        }\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        return setTimeout(fun, 0);\n    } else {\n        return cachedSetTimeout.call(null, fun, 0);\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        clearTimeout(marker);\n    } else {\n        cachedClearTimeout.call(null, marker);\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t__webpack_require__(1);\n\tvar event_target_1 = __webpack_require__(2);\n\tvar define_property_1 = __webpack_require__(4);\n\tvar register_element_1 = __webpack_require__(5);\n\tvar property_descriptor_1 = __webpack_require__(6);\n\tvar timers_1 = __webpack_require__(8);\n\tvar utils_1 = __webpack_require__(3);\n\tvar set = 'set';\n\tvar clear = 'clear';\n\tvar blockingMethods = ['alert', 'prompt', 'confirm'];\n\tvar _global = typeof window == 'undefined' ? global : window;\n\ttimers_1.patchTimer(_global, set, clear, 'Timeout');\n\ttimers_1.patchTimer(_global, set, clear, 'Interval');\n\ttimers_1.patchTimer(_global, set, clear, 'Immediate');\n\ttimers_1.patchTimer(_global, 'request', 'cancel', 'AnimationFrame');\n\ttimers_1.patchTimer(_global, 'mozRequest', 'mozCancel', 'AnimationFrame');\n\ttimers_1.patchTimer(_global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');\n\tfor (var i = 0; i < blockingMethods.length; i++) {\n\t    var name = blockingMethods[i];\n\t    utils_1.patchMethod(_global, name, function (delegate, symbol, name) {\n\t        return function (s, args) {\n\t            return Zone.current.run(delegate, _global, args, name);\n\t        };\n\t    });\n\t}\n\tevent_target_1.eventTargetPatch(_global);\n\tproperty_descriptor_1.propertyDescriptorPatch(_global);\n\tutils_1.patchClass('MutationObserver');\n\tutils_1.patchClass('WebKitMutationObserver');\n\tutils_1.patchClass('FileReader');\n\tdefine_property_1.propertyPatch();\n\tregister_element_1.registerElementPatch(_global);\n\t// Treat XMLHTTPRequest as a macrotask.\n\tpatchXHR(_global);\n\tvar XHR_TASK = utils_1.zoneSymbol('xhrTask');\n\tfunction patchXHR(window) {\n\t    function findPendingTask(target) {\n\t        var pendingTask = target[XHR_TASK];\n\t        return pendingTask;\n\t    }\n\t    function scheduleTask(task) {\n\t        var data = task.data;\n\t        data.target.addEventListener('readystatechange', function () {\n\t            if (data.target.readyState === XMLHttpRequest.DONE) {\n\t                if (!data.aborted) {\n\t                    task.invoke();\n\t                }\n\t            }\n\t        });\n\t        var storedTask = data.target[XHR_TASK];\n\t        if (!storedTask) {\n\t            data.target[XHR_TASK] = task;\n\t        }\n\t        setNative.apply(data.target, data.args);\n\t        return task;\n\t    }\n\t    function placeholderCallback() {\n\t    }\n\t    function clearTask(task) {\n\t        var data = task.data;\n\t        // Note - ideally, we would call data.target.removeEventListener here, but it's too late\n\t        // to prevent it from firing. So instead, we store info for the event listener.\n\t        data.aborted = true;\n\t        return clearNative.apply(data.target, data.args);\n\t    }\n\t    var setNative = utils_1.patchMethod(window.XMLHttpRequest.prototype, 'send', function () { return function (self, args) {\n\t        var zone = Zone.current;\n\t        var options = {\n\t            target: self,\n\t            isPeriodic: false,\n\t            delay: null,\n\t            args: args,\n\t            aborted: false\n\t        };\n\t        return zone.scheduleMacroTask('XMLHttpRequest.send', placeholderCallback, options, scheduleTask, clearTask);\n\t    }; });\n\t    var clearNative = utils_1.patchMethod(window.XMLHttpRequest.prototype, 'abort', function (delegate) { return function (self, args) {\n\t        var task = findPendingTask(self);\n\t        if (task && typeof task.type == 'string') {\n\t            // If the XHR has already completed, do nothing.\n\t            if (task.cancelFn == null) {\n\t                return;\n\t            }\n\t            task.zone.cancelTask(task);\n\t        }\n\t        // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no task to cancel. Do nothing.\n\t    }; });\n\t}\n\t/// GEO_LOCATION\n\tif (_global['navigator'] && _global['navigator'].geolocation) {\n\t    utils_1.patchPrototype(_global['navigator'].geolocation, [\n\t        'getCurrentPosition',\n\t        'watchPosition'\n\t    ]);\n\t}\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {;\n\t;\n\tvar Zone = (function (global) {\n\t    if (global.Zone) {\n\t        throw new Error('Zone already loaded.');\n\t    }\n\t    var Zone = (function () {\n\t        function Zone(parent, zoneSpec) {\n\t            this._properties = null;\n\t            this._parent = parent;\n\t            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n\t            this._properties = zoneSpec && zoneSpec.properties || {};\n\t            this._zoneDelegate = new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n\t        }\n\t        Object.defineProperty(Zone, \"current\", {\n\t            get: function () { return _currentZone; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        ;\n\t        Object.defineProperty(Zone, \"currentTask\", {\n\t            get: function () { return _currentTask; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        ;\n\t        Object.defineProperty(Zone.prototype, \"parent\", {\n\t            get: function () { return this._parent; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        ;\n\t        Object.defineProperty(Zone.prototype, \"name\", {\n\t            get: function () { return this._name; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        ;\n\t        Zone.prototype.get = function (key) {\n\t            var zone = this.getZoneWith(key);\n\t            if (zone)\n\t                return zone._properties[key];\n\t        };\n\t        Zone.prototype.getZoneWith = function (key) {\n\t            var current = this;\n\t            while (current) {\n\t                if (current._properties.hasOwnProperty(key)) {\n\t                    return current;\n\t                }\n\t                current = current._parent;\n\t            }\n\t            return null;\n\t        };\n\t        Zone.prototype.fork = function (zoneSpec) {\n\t            if (!zoneSpec)\n\t                throw new Error('ZoneSpec required!');\n\t            return this._zoneDelegate.fork(this, zoneSpec);\n\t        };\n\t        Zone.prototype.wrap = function (callback, source) {\n\t            if (typeof callback !== 'function') {\n\t                throw new Error('Expecting function got: ' + callback);\n\t            }\n\t            var _callback = this._zoneDelegate.intercept(this, callback, source);\n\t            var zone = this;\n\t            return function () {\n\t                return zone.runGuarded(_callback, this, arguments, source);\n\t            };\n\t        };\n\t        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {\n\t            if (applyThis === void 0) { applyThis = null; }\n\t            if (applyArgs === void 0) { applyArgs = null; }\n\t            if (source === void 0) { source = null; }\n\t            var oldZone = _currentZone;\n\t            _currentZone = this;\n\t            try {\n\t                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n\t            }\n\t            finally {\n\t                _currentZone = oldZone;\n\t            }\n\t        };\n\t        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {\n\t            if (applyThis === void 0) { applyThis = null; }\n\t            if (applyArgs === void 0) { applyArgs = null; }\n\t            if (source === void 0) { source = null; }\n\t            var oldZone = _currentZone;\n\t            _currentZone = this;\n\t            try {\n\t                try {\n\t                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n\t                }\n\t                catch (error) {\n\t                    if (this._zoneDelegate.handleError(this, error)) {\n\t                        throw error;\n\t                    }\n\t                }\n\t            }\n\t            finally {\n\t                _currentZone = oldZone;\n\t            }\n\t        };\n\t        Zone.prototype.runTask = function (task, applyThis, applyArgs) {\n\t            task.runCount++;\n\t            if (task.zone != this)\n\t                throw new Error('A task can only be run in the zone which created it! (Creation: ' +\n\t                    task.zone.name + '; Execution: ' + this.name + ')');\n\t            var previousTask = _currentTask;\n\t            _currentTask = task;\n\t            var oldZone = _currentZone;\n\t            _currentZone = this;\n\t            try {\n\t                if (task.type == 'macroTask' && task.data && !task.data.isPeriodic) {\n\t                    task.cancelFn = null;\n\t                }\n\t                try {\n\t                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n\t                }\n\t                catch (error) {\n\t                    if (this._zoneDelegate.handleError(this, error)) {\n\t                        throw error;\n\t                    }\n\t                }\n\t            }\n\t            finally {\n\t                _currentZone = oldZone;\n\t                _currentTask = previousTask;\n\t            }\n\t        };\n\t        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {\n\t            return this._zoneDelegate.scheduleTask(this, new ZoneTask('microTask', this, source, callback, data, customSchedule, null));\n\t        };\n\t        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {\n\t            return this._zoneDelegate.scheduleTask(this, new ZoneTask('macroTask', this, source, callback, data, customSchedule, customCancel));\n\t        };\n\t        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {\n\t            return this._zoneDelegate.scheduleTask(this, new ZoneTask('eventTask', this, source, callback, data, customSchedule, customCancel));\n\t        };\n\t        Zone.prototype.cancelTask = function (task) {\n\t            var value = this._zoneDelegate.cancelTask(this, task);\n\t            task.runCount = -1;\n\t            task.cancelFn = null;\n\t            return value;\n\t        };\n\t        Zone.__symbol__ = __symbol__;\n\t        return Zone;\n\t    }());\n\t    ;\n\t    var ZoneDelegate = (function () {\n\t        function ZoneDelegate(zone, parentDelegate, zoneSpec) {\n\t            this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 };\n\t            this.zone = zone;\n\t            this._parentDelegate = parentDelegate;\n\t            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n\t            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n\t            this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n\t            this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n\t            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n\t            this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n\t            this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n\t            this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n\t            this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n\t            this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n\t            this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n\t            this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n\t            this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n\t            this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n\t            this._hasTaskZS = zoneSpec && (zoneSpec.onHasTask ? zoneSpec : parentDelegate._hasTaskZS);\n\t            this._hasTaskDlgt = zoneSpec && (zoneSpec.onHasTask ? parentDelegate : parentDelegate._hasTaskDlgt);\n\t        }\n\t        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {\n\t            return this._forkZS\n\t                ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec)\n\t                : new Zone(targetZone, zoneSpec);\n\t        };\n\t        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {\n\t            return this._interceptZS\n\t                ? this._interceptZS.onIntercept(this._interceptDlgt, this.zone, targetZone, callback, source)\n\t                : callback;\n\t        };\n\t        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {\n\t            return this._invokeZS\n\t                ? this._invokeZS.onInvoke(this._invokeDlgt, this.zone, targetZone, callback, applyThis, applyArgs, source)\n\t                : callback.apply(applyThis, applyArgs);\n\t        };\n\t        ZoneDelegate.prototype.handleError = function (targetZone, error) {\n\t            return this._handleErrorZS\n\t                ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this.zone, targetZone, error)\n\t                : true;\n\t        };\n\t        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {\n\t            try {\n\t                if (this._scheduleTaskZS) {\n\t                    return this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this.zone, targetZone, task);\n\t                }\n\t                else if (task.scheduleFn) {\n\t                    task.scheduleFn(task);\n\t                }\n\t                else if (task.type == 'microTask') {\n\t                    scheduleMicroTask(task);\n\t                }\n\t                else {\n\t                    throw new Error('Task is missing scheduleFn.');\n\t                }\n\t                return task;\n\t            }\n\t            finally {\n\t                if (targetZone == this.zone) {\n\t                    this._updateTaskCount(task.type, 1);\n\t                }\n\t            }\n\t        };\n\t        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {\n\t            try {\n\t                return this._invokeTaskZS\n\t                    ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this.zone, targetZone, task, applyThis, applyArgs)\n\t                    : task.callback.apply(applyThis, applyArgs);\n\t            }\n\t            finally {\n\t                if (targetZone == this.zone && (task.type != 'eventTask') && !(task.data && task.data.isPeriodic)) {\n\t                    this._updateTaskCount(task.type, -1);\n\t                }\n\t            }\n\t        };\n\t        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {\n\t            var value;\n\t            if (this._cancelTaskZS) {\n\t                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this.zone, targetZone, task);\n\t            }\n\t            else if (!task.cancelFn) {\n\t                throw new Error('Task does not support cancellation, or is already canceled.');\n\t            }\n\t            else {\n\t                value = task.cancelFn(task);\n\t            }\n\t            if (targetZone == this.zone) {\n\t                // this should not be in the finally block, because exceptions assume not canceled.\n\t                this._updateTaskCount(task.type, -1);\n\t            }\n\t            return value;\n\t        };\n\t        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {\n\t            return this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this.zone, targetZone, isEmpty);\n\t        };\n\t        ZoneDelegate.prototype._updateTaskCount = function (type, count) {\n\t            var counts = this._taskCounts;\n\t            var prev = counts[type];\n\t            var next = counts[type] = prev + count;\n\t            if (next < 0) {\n\t                throw new Error('More tasks executed then were scheduled.');\n\t            }\n\t            if (prev == 0 || next == 0) {\n\t                var isEmpty = {\n\t                    microTask: counts.microTask > 0,\n\t                    macroTask: counts.macroTask > 0,\n\t                    eventTask: counts.eventTask > 0,\n\t                    change: type\n\t                };\n\t                try {\n\t                    this.hasTask(this.zone, isEmpty);\n\t                }\n\t                finally {\n\t                    if (this._parentDelegate) {\n\t                        this._parentDelegate._updateTaskCount(type, count);\n\t                    }\n\t                }\n\t            }\n\t        };\n\t        return ZoneDelegate;\n\t    }());\n\t    var ZoneTask = (function () {\n\t        function ZoneTask(type, zone, source, callback, options, scheduleFn, cancelFn) {\n\t            this.runCount = 0;\n\t            this.type = type;\n\t            this.zone = zone;\n\t            this.source = source;\n\t            this.data = options;\n\t            this.scheduleFn = scheduleFn;\n\t            this.cancelFn = cancelFn;\n\t            this.callback = callback;\n\t            var self = this;\n\t            this.invoke = function () {\n\t                _numberOfNestedTaskFrames++;\n\t                try {\n\t                    return zone.runTask(self, this, arguments);\n\t                }\n\t                finally {\n\t                    if (_numberOfNestedTaskFrames == 1) {\n\t                        drainMicroTaskQueue();\n\t                    }\n\t                    _numberOfNestedTaskFrames--;\n\t                }\n\t            };\n\t        }\n\t        ZoneTask.prototype.toString = function () {\n\t            if (this.data && typeof this.data.handleId !== 'undefined') {\n\t                return this.data.handleId;\n\t            }\n\t            else {\n\t                return this.toString();\n\t            }\n\t        };\n\t        return ZoneTask;\n\t    }());\n\t    function __symbol__(name) { return '__zone_symbol__' + name; }\n\t    ;\n\t    var symbolSetTimeout = __symbol__('setTimeout');\n\t    var symbolPromise = __symbol__('Promise');\n\t    var symbolThen = __symbol__('then');\n\t    var _currentZone = new Zone(null, null);\n\t    var _currentTask = null;\n\t    var _microTaskQueue = [];\n\t    var _isDrainingMicrotaskQueue = false;\n\t    var _uncaughtPromiseErrors = [];\n\t    var _numberOfNestedTaskFrames = 0;\n\t    function scheduleQueueDrain() {\n\t        // if we are not running in any task, and there has not been anything scheduled\n\t        // we must bootstrap the initial task creation by manually scheduling the drain\n\t        if (_numberOfNestedTaskFrames == 0 && _microTaskQueue.length == 0) {\n\t            // We are not running in Task, so we need to kickstart the microtask queue.\n\t            if (global[symbolPromise]) {\n\t                global[symbolPromise].resolve(0)[symbolThen](drainMicroTaskQueue);\n\t            }\n\t            else {\n\t                global[symbolSetTimeout](drainMicroTaskQueue, 0);\n\t            }\n\t        }\n\t    }\n\t    function scheduleMicroTask(task) {\n\t        scheduleQueueDrain();\n\t        _microTaskQueue.push(task);\n\t    }\n\t    function consoleError(e) {\n\t        var rejection = e && e.rejection;\n\t        if (rejection) {\n\t            console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n\t        }\n\t        console.error(e);\n\t    }\n\t    function drainMicroTaskQueue() {\n\t        if (!_isDrainingMicrotaskQueue) {\n\t            _isDrainingMicrotaskQueue = true;\n\t            while (_microTaskQueue.length) {\n\t                var queue = _microTaskQueue;\n\t                _microTaskQueue = [];\n\t                for (var i = 0; i < queue.length; i++) {\n\t                    var task = queue[i];\n\t                    try {\n\t                        task.zone.runTask(task, null, null);\n\t                    }\n\t                    catch (e) {\n\t                        consoleError(e);\n\t                    }\n\t                }\n\t            }\n\t            while (_uncaughtPromiseErrors.length) {\n\t                var _loop_1 = function() {\n\t                    var uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n\t                    try {\n\t                        uncaughtPromiseError.zone.runGuarded(function () { throw uncaughtPromiseError; });\n\t                    }\n\t                    catch (e) {\n\t                        consoleError(e);\n\t                    }\n\t                };\n\t                while (_uncaughtPromiseErrors.length) {\n\t                    _loop_1();\n\t                }\n\t            }\n\t            _isDrainingMicrotaskQueue = false;\n\t        }\n\t    }\n\t    function isThenable(value) {\n\t        return value && value.then;\n\t    }\n\t    function forwardResolution(value) { return value; }\n\t    function forwardRejection(rejection) { return ZoneAwarePromise.reject(rejection); }\n\t    var symbolState = __symbol__('state');\n\t    var symbolValue = __symbol__('value');\n\t    var source = 'Promise.then';\n\t    var UNRESOLVED = null;\n\t    var RESOLVED = true;\n\t    var REJECTED = false;\n\t    var REJECTED_NO_CATCH = 0;\n\t    function makeResolver(promise, state) {\n\t        return function (v) {\n\t            resolvePromise(promise, state, v);\n\t            // Do not return value or you will break the Promise spec.\n\t        };\n\t    }\n\t    function resolvePromise(promise, state, value) {\n\t        if (promise[symbolState] === UNRESOLVED) {\n\t            if (value instanceof ZoneAwarePromise && value[symbolState] !== UNRESOLVED) {\n\t                clearRejectedNoCatch(value);\n\t                resolvePromise(promise, value[symbolState], value[symbolValue]);\n\t            }\n\t            else if (isThenable(value)) {\n\t                value.then(makeResolver(promise, state), makeResolver(promise, false));\n\t            }\n\t            else {\n\t                promise[symbolState] = state;\n\t                var queue = promise[symbolValue];\n\t                promise[symbolValue] = value;\n\t                for (var i = 0; i < queue.length;) {\n\t                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n\t                }\n\t                if (queue.length == 0 && state == REJECTED) {\n\t                    promise[symbolState] = REJECTED_NO_CATCH;\n\t                    try {\n\t                        throw new Error(\"Uncaught (in promise): \" + value);\n\t                    }\n\t                    catch (e) {\n\t                        var error = e;\n\t                        error.rejection = value;\n\t                        error.promise = promise;\n\t                        error.zone = Zone.current;\n\t                        error.task = Zone.currentTask;\n\t                        _uncaughtPromiseErrors.push(error);\n\t                        scheduleQueueDrain();\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        // Resolving an already resolved promise is a noop.\n\t        return promise;\n\t    }\n\t    function clearRejectedNoCatch(promise) {\n\t        if (promise[symbolState] === REJECTED_NO_CATCH) {\n\t            promise[symbolState] = REJECTED;\n\t            for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {\n\t                if (promise === _uncaughtPromiseErrors[i].promise) {\n\t                    _uncaughtPromiseErrors.splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n\t        clearRejectedNoCatch(promise);\n\t        var delegate = promise[symbolState] ? onFulfilled || forwardResolution : onRejected || forwardRejection;\n\t        zone.scheduleMicroTask(source, function () {\n\t            try {\n\t                resolvePromise(chainPromise, true, zone.run(delegate, null, [promise[symbolValue]]));\n\t            }\n\t            catch (error) {\n\t                resolvePromise(chainPromise, false, error);\n\t            }\n\t        });\n\t    }\n\t    var ZoneAwarePromise = (function () {\n\t        function ZoneAwarePromise(executor) {\n\t            var promise = this;\n\t            if (!(promise instanceof ZoneAwarePromise)) {\n\t                throw new Error('Must be an instanceof Promise.');\n\t            }\n\t            promise[symbolState] = UNRESOLVED;\n\t            promise[symbolValue] = []; // queue;\n\t            try {\n\t                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\n\t            }\n\t            catch (e) {\n\t                resolvePromise(promise, false, e);\n\t            }\n\t        }\n\t        ZoneAwarePromise.resolve = function (value) {\n\t            return resolvePromise(new this(null), RESOLVED, value);\n\t        };\n\t        ZoneAwarePromise.reject = function (error) {\n\t            return resolvePromise(new this(null), REJECTED, error);\n\t        };\n\t        ZoneAwarePromise.race = function (values) {\n\t            var resolve;\n\t            var reject;\n\t            var promise = new this(function (res, rej) { resolve = res; reject = rej; });\n\t            function onResolve(value) { promise && (promise = null || resolve(value)); }\n\t            function onReject(error) { promise && (promise = null || reject(error)); }\n\t            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n\t                var value = values_1[_i];\n\t                if (!isThenable(value)) {\n\t                    value = this.resolve(value);\n\t                }\n\t                value.then(onResolve, onReject);\n\t            }\n\t            return promise;\n\t        };\n\t        ZoneAwarePromise.all = function (values) {\n\t            var resolve;\n\t            var reject;\n\t            var promise = new this(function (res, rej) { resolve = res; reject = rej; });\n\t            var count = 0;\n\t            var resolvedValues = [];\n\t            function onReject(error) { promise && reject(error); promise = null; }\n\t            for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n\t                var value = values_2[_i];\n\t                if (!isThenable(value)) {\n\t                    value = this.resolve(value);\n\t                }\n\t                value.then((function (index) { return function (value) {\n\t                    resolvedValues[index] = value;\n\t                    count--;\n\t                    if (promise && !count) {\n\t                        resolve(resolvedValues);\n\t                    }\n\t                    promise == null;\n\t                }; })(count), onReject);\n\t                count++;\n\t            }\n\t            if (!count)\n\t                resolve(resolvedValues);\n\t            return promise;\n\t        };\n\t        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {\n\t            var chainPromise = new this.constructor(null);\n\t            var zone = Zone.current;\n\t            if (this[symbolState] == UNRESOLVED) {\n\t                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n\t            }\n\t            else {\n\t                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n\t            }\n\t            return chainPromise;\n\t        };\n\t        ZoneAwarePromise.prototype.catch = function (onRejected) {\n\t            return this.then(null, onRejected);\n\t        };\n\t        return ZoneAwarePromise;\n\t    }());\n\t    var NativePromise = global[__symbol__('Promise')] = global.Promise;\n\t    global.Promise = ZoneAwarePromise;\n\t    if (NativePromise) {\n\t        var NativePromiseProtototype = NativePromise.prototype;\n\t        var NativePromiseThen_1 = NativePromiseProtototype[__symbol__('then')]\n\t            = NativePromiseProtototype.then;\n\t        NativePromiseProtototype.then = function (onResolve, onReject) {\n\t            var nativePromise = this;\n\t            return new ZoneAwarePromise(function (resolve, reject) {\n\t                NativePromiseThen_1.call(nativePromise, resolve, reject);\n\t            }).then(onResolve, onReject);\n\t        };\n\t    }\n\t    // This is not part of public API, but it is usefull for tests, so we expose it.\n\t    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n\t    return global.Zone = Zone;\n\t})(typeof window === 'undefined' ? global : window);\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(3);\n\tvar WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';\n\tvar NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex'.split(',');\n\tvar EVENT_TARGET = 'EventTarget';\n\tfunction eventTargetPatch(_global) {\n\t    var apis = [];\n\t    var isWtf = _global['wtf'];\n\t    if (isWtf) {\n\t        // Workaround for: https://github.com/google/tracing-framework/issues/555\n\t        apis = WTF_ISSUE_555.split(',').map(function (v) { return 'HTML' + v + 'Element'; }).concat(NO_EVENT_TARGET);\n\t    }\n\t    else if (_global[EVENT_TARGET]) {\n\t        apis.push(EVENT_TARGET);\n\t    }\n\t    else {\n\t        // Note: EventTarget is not available in all browsers,\n\t        // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget\n\t        apis = NO_EVENT_TARGET;\n\t    }\n\t    for (var i = 0; i < apis.length; i++) {\n\t        var type = _global[apis[i]];\n\t        utils_1.patchEventTargetMethods(type && type.prototype);\n\t    }\n\t}\n\texports.eventTargetPatch = eventTargetPatch;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Suppress closure compiler errors about unknown 'process' variable\n\t * @fileoverview\n\t * @suppress {undefinedVars}\n\t */\n\t\"use strict\";\n\texports.zoneSymbol = Zone['__symbol__'];\n\tvar _global = typeof window == 'undefined' ? global : window;\n\tfunction bindArguments(args, source) {\n\t    for (var i = args.length - 1; i >= 0; i--) {\n\t        if (typeof args[i] === 'function') {\n\t            args[i] = Zone.current.wrap(args[i], source + '_' + i);\n\t        }\n\t    }\n\t    return args;\n\t}\n\texports.bindArguments = bindArguments;\n\t;\n\tfunction patchPrototype(prototype, fnNames) {\n\t    var source = prototype.constructor['name'];\n\t    var _loop_1 = function(i) {\n\t        var name_1 = fnNames[i];\n\t        var delegate = prototype[name_1];\n\t        if (delegate) {\n\t            prototype[name_1] = (function (delegate) {\n\t                return function () {\n\t                    return delegate.apply(this, bindArguments(arguments, source + '.' + name_1));\n\t                };\n\t            })(delegate);\n\t        }\n\t    };\n\t    for (var i = 0; i < fnNames.length; i++) {\n\t        _loop_1(i);\n\t    }\n\t}\n\texports.patchPrototype = patchPrototype;\n\t;\n\texports.isWebWorker = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);\n\texports.isNode = (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]');\n\texports.isBrowser = !exports.isNode && !exports.isWebWorker && !!(typeof window !== 'undefined' && window['HTMLElement']);\n\tfunction patchProperty(obj, prop) {\n\t    var desc = Object.getOwnPropertyDescriptor(obj, prop) || {\n\t        enumerable: true,\n\t        configurable: true\n\t    };\n\t    // A property descriptor cannot have getter/setter and be writable\n\t    // deleting the writable and value properties avoids this error:\n\t    //\n\t    // TypeError: property descriptors must not specify a value or be writable when a\n\t    // getter or setter has been specified\n\t    delete desc.writable;\n\t    delete desc.value;\n\t    // substr(2) cuz 'onclick' -> 'click', etc\n\t    var eventName = prop.substr(2);\n\t    var _prop = '_' + prop;\n\t    desc.set = function (fn) {\n\t        if (this[_prop]) {\n\t            this.removeEventListener(eventName, this[_prop]);\n\t        }\n\t        if (typeof fn === 'function') {\n\t            var wrapFn = function (event) {\n\t                var result;\n\t                result = fn.apply(this, arguments);\n\t                if (result != undefined && !result)\n\t                    event.preventDefault();\n\t            };\n\t            this[_prop] = wrapFn;\n\t            this.addEventListener(eventName, wrapFn, false);\n\t        }\n\t        else {\n\t            this[_prop] = null;\n\t        }\n\t    };\n\t    desc.get = function () {\n\t        return this[_prop];\n\t    };\n\t    Object.defineProperty(obj, prop, desc);\n\t}\n\texports.patchProperty = patchProperty;\n\t;\n\tfunction patchOnProperties(obj, properties) {\n\t    var onProperties = [];\n\t    for (var prop in obj) {\n\t        if (prop.substr(0, 2) == 'on') {\n\t            onProperties.push(prop);\n\t        }\n\t    }\n\t    for (var j = 0; j < onProperties.length; j++) {\n\t        patchProperty(obj, onProperties[j]);\n\t    }\n\t    if (properties) {\n\t        for (var i = 0; i < properties.length; i++) {\n\t            patchProperty(obj, 'on' + properties[i]);\n\t        }\n\t    }\n\t}\n\texports.patchOnProperties = patchOnProperties;\n\t;\n\tvar EVENT_TASKS = exports.zoneSymbol('eventTasks');\n\tvar ADD_EVENT_LISTENER = 'addEventListener';\n\tvar REMOVE_EVENT_LISTENER = 'removeEventListener';\n\tvar SYMBOL_ADD_EVENT_LISTENER = exports.zoneSymbol(ADD_EVENT_LISTENER);\n\tvar SYMBOL_REMOVE_EVENT_LISTENER = exports.zoneSymbol(REMOVE_EVENT_LISTENER);\n\tfunction findExistingRegisteredTask(target, handler, name, capture, remove) {\n\t    var eventTasks = target[EVENT_TASKS];\n\t    if (eventTasks) {\n\t        for (var i = 0; i < eventTasks.length; i++) {\n\t            var eventTask = eventTasks[i];\n\t            var data = eventTask.data;\n\t            if (data.handler === handler\n\t                && data.useCapturing === capture\n\t                && data.eventName === name) {\n\t                if (remove) {\n\t                    eventTasks.splice(i, 1);\n\t                }\n\t                return eventTask;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction attachRegisteredEvent(target, eventTask) {\n\t    var eventTasks = target[EVENT_TASKS];\n\t    if (!eventTasks) {\n\t        eventTasks = target[EVENT_TASKS] = [];\n\t    }\n\t    eventTasks.push(eventTask);\n\t}\n\tfunction scheduleEventListener(eventTask) {\n\t    var meta = eventTask.data;\n\t    attachRegisteredEvent(meta.target, eventTask);\n\t    return meta.target[SYMBOL_ADD_EVENT_LISTENER](meta.eventName, eventTask.invoke, meta.useCapturing);\n\t}\n\tfunction cancelEventListener(eventTask) {\n\t    var meta = eventTask.data;\n\t    findExistingRegisteredTask(meta.target, eventTask.invoke, meta.eventName, meta.useCapturing, true);\n\t    meta.target[SYMBOL_REMOVE_EVENT_LISTENER](meta.eventName, eventTask.invoke, meta.useCapturing);\n\t}\n\tfunction zoneAwareAddEventListener(self, args) {\n\t    var eventName = args[0];\n\t    var handler = args[1];\n\t    var useCapturing = args[2] || false;\n\t    // - Inside a Web Worker, `this` is undefined, the context is `global`\n\t    // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n\t    // see https://github.com/angular/zone.js/issues/190\n\t    var target = self || _global;\n\t    var delegate = null;\n\t    if (typeof handler == 'function') {\n\t        delegate = handler;\n\t    }\n\t    else if (handler && handler.handleEvent) {\n\t        delegate = function (event) { return handler.handleEvent(event); };\n\t    }\n\t    var validZoneHandler = false;\n\t    try {\n\t        // In cross site contexts (such as WebDriver frameworks like Selenium),\n\t        // accessing the handler object here will cause an exception to be thrown which\n\t        // will fail tests prematurely.\n\t        validZoneHandler = handler && handler.toString() === \"[object FunctionWrapper]\";\n\t    }\n\t    catch (e) {\n\t        // Returning nothing here is fine, because objects in a cross-site context are unusable\n\t        return;\n\t    }\n\t    // Ignore special listeners of IE11 & Edge dev tools, see https://github.com/angular/zone.js/issues/150\n\t    if (!delegate || validZoneHandler) {\n\t        return target[SYMBOL_ADD_EVENT_LISTENER](eventName, handler, useCapturing);\n\t    }\n\t    var eventTask = findExistingRegisteredTask(target, handler, eventName, useCapturing, false);\n\t    if (eventTask) {\n\t        // we already registered, so this will have noop.\n\t        return target[SYMBOL_ADD_EVENT_LISTENER](eventName, eventTask.invoke, useCapturing);\n\t    }\n\t    var zone = Zone.current;\n\t    var source = target.constructor['name'] + '.addEventListener:' + eventName;\n\t    var data = {\n\t        target: target,\n\t        eventName: eventName,\n\t        name: eventName,\n\t        useCapturing: useCapturing,\n\t        handler: handler\n\t    };\n\t    zone.scheduleEventTask(source, delegate, data, scheduleEventListener, cancelEventListener);\n\t}\n\tfunction zoneAwareRemoveEventListener(self, args) {\n\t    var eventName = args[0];\n\t    var handler = args[1];\n\t    var useCapturing = args[2] || false;\n\t    // - Inside a Web Worker, `this` is undefined, the context is `global`\n\t    // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n\t    // see https://github.com/angular/zone.js/issues/190\n\t    var target = self || _global;\n\t    var eventTask = findExistingRegisteredTask(target, handler, eventName, useCapturing, true);\n\t    if (eventTask) {\n\t        eventTask.zone.cancelTask(eventTask);\n\t    }\n\t    else {\n\t        target[SYMBOL_REMOVE_EVENT_LISTENER](eventName, handler, useCapturing);\n\t    }\n\t}\n\tfunction patchEventTargetMethods(obj) {\n\t    if (obj && obj.addEventListener) {\n\t        patchMethod(obj, ADD_EVENT_LISTENER, function () { return zoneAwareAddEventListener; });\n\t        patchMethod(obj, REMOVE_EVENT_LISTENER, function () { return zoneAwareRemoveEventListener; });\n\t        return true;\n\t    }\n\t    else {\n\t        return false;\n\t    }\n\t}\n\texports.patchEventTargetMethods = patchEventTargetMethods;\n\t;\n\tvar originalInstanceKey = exports.zoneSymbol('originalInstance');\n\t// wrap some native API on `window`\n\tfunction patchClass(className) {\n\t    var OriginalClass = _global[className];\n\t    if (!OriginalClass)\n\t        return;\n\t    _global[className] = function () {\n\t        var a = bindArguments(arguments, className);\n\t        switch (a.length) {\n\t            case 0:\n\t                this[originalInstanceKey] = new OriginalClass();\n\t                break;\n\t            case 1:\n\t                this[originalInstanceKey] = new OriginalClass(a[0]);\n\t                break;\n\t            case 2:\n\t                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n\t                break;\n\t            case 3:\n\t                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n\t                break;\n\t            case 4:\n\t                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n\t                break;\n\t            default: throw new Error('Arg list too long.');\n\t        }\n\t    };\n\t    var instance = new OriginalClass(function () { });\n\t    var prop;\n\t    for (prop in instance) {\n\t        // https://bugs.webkit.org/show_bug.cgi?id=44721\n\t        if (className === 'XMLHttpRequest' && prop === 'responseBlob')\n\t            continue;\n\t        (function (prop) {\n\t            if (typeof instance[prop] === 'function') {\n\t                _global[className].prototype[prop] = function () {\n\t                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n\t                };\n\t            }\n\t            else {\n\t                Object.defineProperty(_global[className].prototype, prop, {\n\t                    set: function (fn) {\n\t                        if (typeof fn === 'function') {\n\t                            this[originalInstanceKey][prop] = Zone.current.wrap(fn, className + '.' + prop);\n\t                        }\n\t                        else {\n\t                            this[originalInstanceKey][prop] = fn;\n\t                        }\n\t                    },\n\t                    get: function () {\n\t                        return this[originalInstanceKey][prop];\n\t                    }\n\t                });\n\t            }\n\t        }(prop));\n\t    }\n\t    for (prop in OriginalClass) {\n\t        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n\t            _global[className][prop] = OriginalClass[prop];\n\t        }\n\t    }\n\t}\n\texports.patchClass = patchClass;\n\t;\n\tfunction createNamedFn(name, delegate) {\n\t    try {\n\t        return (Function('f', \"return function \" + name + \"(){return f(this, arguments)}\"))(delegate);\n\t    }\n\t    catch (e) {\n\t        // if we fail, we must be CSP, just return delegate.\n\t        return function () {\n\t            return delegate(this, arguments);\n\t        };\n\t    }\n\t}\n\texports.createNamedFn = createNamedFn;\n\tfunction patchMethod(target, name, patchFn) {\n\t    var proto = target;\n\t    while (proto && !proto.hasOwnProperty(name)) {\n\t        proto = Object.getPrototypeOf(proto);\n\t    }\n\t    if (!proto && target[name]) {\n\t        // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n\t        proto = target;\n\t    }\n\t    var delegateName = exports.zoneSymbol(name);\n\t    var delegate;\n\t    if (proto && !(delegate = proto[delegateName])) {\n\t        delegate = proto[delegateName] = proto[name];\n\t        proto[name] = createNamedFn(name, patchFn(delegate, delegateName, name));\n\t    }\n\t    return delegate;\n\t}\n\texports.patchMethod = patchMethod;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(3);\n\t/*\n\t * This is necessary for Chrome and Chrome mobile, to enable\n\t * things like redefining `createdCallback` on an element.\n\t */\n\tvar _defineProperty = Object.defineProperty;\n\tvar _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\tvar _create = Object.create;\n\tvar unconfigurablesKey = utils_1.zoneSymbol('unconfigurables');\n\tfunction propertyPatch() {\n\t    Object.defineProperty = function (obj, prop, desc) {\n\t        if (isUnconfigurable(obj, prop)) {\n\t            throw new TypeError('Cannot assign to read only property \\'' + prop + '\\' of ' + obj);\n\t        }\n\t        var originalConfigurableFlag = desc.configurable;\n\t        if (prop !== 'prototype') {\n\t            desc = rewriteDescriptor(obj, prop, desc);\n\t        }\n\t        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n\t    };\n\t    Object.defineProperties = function (obj, props) {\n\t        Object.keys(props).forEach(function (prop) {\n\t            Object.defineProperty(obj, prop, props[prop]);\n\t        });\n\t        return obj;\n\t    };\n\t    Object.create = function (obj, proto) {\n\t        if (typeof proto === 'object' && !Object.isFrozen(proto)) {\n\t            Object.keys(proto).forEach(function (prop) {\n\t                proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);\n\t            });\n\t        }\n\t        return _create(obj, proto);\n\t    };\n\t    Object.getOwnPropertyDescriptor = function (obj, prop) {\n\t        var desc = _getOwnPropertyDescriptor(obj, prop);\n\t        if (isUnconfigurable(obj, prop)) {\n\t            desc.configurable = false;\n\t        }\n\t        return desc;\n\t    };\n\t}\n\texports.propertyPatch = propertyPatch;\n\t;\n\tfunction _redefineProperty(obj, prop, desc) {\n\t    var originalConfigurableFlag = desc.configurable;\n\t    desc = rewriteDescriptor(obj, prop, desc);\n\t    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n\t}\n\texports._redefineProperty = _redefineProperty;\n\t;\n\tfunction isUnconfigurable(obj, prop) {\n\t    return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];\n\t}\n\tfunction rewriteDescriptor(obj, prop, desc) {\n\t    desc.configurable = true;\n\t    if (!desc.configurable) {\n\t        if (!obj[unconfigurablesKey]) {\n\t            _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });\n\t        }\n\t        obj[unconfigurablesKey][prop] = true;\n\t    }\n\t    return desc;\n\t}\n\tfunction _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {\n\t    try {\n\t        return _defineProperty(obj, prop, desc);\n\t    }\n\t    catch (e) {\n\t        if (desc.configurable) {\n\t            // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's retry with the original flag value\n\t            if (typeof originalConfigurableFlag == 'undefined') {\n\t                delete desc.configurable;\n\t            }\n\t            else {\n\t                desc.configurable = originalConfigurableFlag;\n\t            }\n\t            return _defineProperty(obj, prop, desc);\n\t        }\n\t        else {\n\t            throw e;\n\t        }\n\t    }\n\t}\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar define_property_1 = __webpack_require__(4);\n\tvar utils_1 = __webpack_require__(3);\n\tfunction registerElementPatch(_global) {\n\t    if (!utils_1.isBrowser || !('registerElement' in _global.document)) {\n\t        return;\n\t    }\n\t    var _registerElement = document.registerElement;\n\t    var callbacks = [\n\t        'createdCallback',\n\t        'attachedCallback',\n\t        'detachedCallback',\n\t        'attributeChangedCallback'\n\t    ];\n\t    document.registerElement = function (name, opts) {\n\t        if (opts && opts.prototype) {\n\t            callbacks.forEach(function (callback) {\n\t                var source = 'Document.registerElement::' + callback;\n\t                if (opts.prototype.hasOwnProperty(callback)) {\n\t                    var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);\n\t                    if (descriptor && descriptor.value) {\n\t                        descriptor.value = Zone.current.wrap(descriptor.value, source);\n\t                        define_property_1._redefineProperty(opts.prototype, callback, descriptor);\n\t                    }\n\t                    else {\n\t                        opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);\n\t                    }\n\t                }\n\t                else if (opts.prototype[callback]) {\n\t                    opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);\n\t                }\n\t            });\n\t        }\n\t        return _registerElement.apply(document, [name, opts]);\n\t    };\n\t}\n\texports.registerElementPatch = registerElementPatch;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar webSocketPatch = __webpack_require__(7);\n\tvar utils_1 = __webpack_require__(3);\n\tvar eventNames = 'copy cut paste abort blur focus canplay canplaythrough change click contextmenu dblclick drag dragend dragenter dragleave dragover dragstart drop durationchange emptied ended input invalid keydown keypress keyup load loadeddata loadedmetadata loadstart message mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup pause play playing progress ratechange reset scroll seeked seeking select show stalled submit suspend timeupdate volumechange waiting mozfullscreenchange mozfullscreenerror mozpointerlockchange mozpointerlockerror error webglcontextrestored webglcontextlost webglcontextcreationerror'.split(' ');\n\tfunction propertyDescriptorPatch(_global) {\n\t    if (utils_1.isNode) {\n\t        return;\n\t    }\n\t    var supportsWebSocket = typeof WebSocket !== 'undefined';\n\t    if (canPatchViaPropertyDescriptor()) {\n\t        // for browsers that we can patch the descriptor:  Chrome & Firefox\n\t        if (utils_1.isBrowser) {\n\t            utils_1.patchOnProperties(HTMLElement.prototype, eventNames);\n\t        }\n\t        utils_1.patchOnProperties(XMLHttpRequest.prototype, null);\n\t        if (typeof IDBIndex !== 'undefined') {\n\t            utils_1.patchOnProperties(IDBIndex.prototype, null);\n\t            utils_1.patchOnProperties(IDBRequest.prototype, null);\n\t            utils_1.patchOnProperties(IDBOpenDBRequest.prototype, null);\n\t            utils_1.patchOnProperties(IDBDatabase.prototype, null);\n\t            utils_1.patchOnProperties(IDBTransaction.prototype, null);\n\t            utils_1.patchOnProperties(IDBCursor.prototype, null);\n\t        }\n\t        if (supportsWebSocket) {\n\t            utils_1.patchOnProperties(WebSocket.prototype, null);\n\t        }\n\t    }\n\t    else {\n\t        // Safari, Android browsers (Jelly Bean)\n\t        patchViaCapturingAllTheEvents();\n\t        utils_1.patchClass('XMLHttpRequest');\n\t        if (supportsWebSocket) {\n\t            webSocketPatch.apply(_global);\n\t        }\n\t    }\n\t}\n\texports.propertyDescriptorPatch = propertyDescriptorPatch;\n\tfunction canPatchViaPropertyDescriptor() {\n\t    if (utils_1.isBrowser && !Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick')\n\t        && typeof Element !== 'undefined') {\n\t        // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364\n\t        // IDL interface attributes are not configurable\n\t        var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');\n\t        if (desc && !desc.configurable)\n\t            return false;\n\t    }\n\t    Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {\n\t        get: function () {\n\t            return true;\n\t        }\n\t    });\n\t    var req = new XMLHttpRequest();\n\t    var result = !!req.onreadystatechange;\n\t    Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {});\n\t    return result;\n\t}\n\t;\n\tvar unboundKey = utils_1.zoneSymbol('unbound');\n\t// Whenever any eventListener fires, we check the eventListener target and all parents\n\t// for `onwhatever` properties and replace them with zone-bound functions\n\t// - Chrome (for now)\n\tfunction patchViaCapturingAllTheEvents() {\n\t    var _loop_1 = function(i) {\n\t        var property = eventNames[i];\n\t        var onproperty = 'on' + property;\n\t        document.addEventListener(property, function (event) {\n\t            var elt = event.target, bound, source;\n\t            if (elt) {\n\t                source = elt.constructor['name'] + '.' + onproperty;\n\t            }\n\t            else {\n\t                source = 'unknown.' + onproperty;\n\t            }\n\t            while (elt) {\n\t                if (elt[onproperty] && !elt[onproperty][unboundKey]) {\n\t                    bound = Zone.current.wrap(elt[onproperty], source);\n\t                    bound[unboundKey] = elt[onproperty];\n\t                    elt[onproperty] = bound;\n\t                }\n\t                elt = elt.parentElement;\n\t            }\n\t        }, true);\n\t    };\n\t    for (var i = 0; i < eventNames.length; i++) {\n\t        _loop_1(i);\n\t    }\n\t    ;\n\t}\n\t;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(3);\n\t// we have to patch the instance since the proto is non-configurable\n\tfunction apply(_global) {\n\t    var WS = _global.WebSocket;\n\t    // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener\n\t    // On older Chrome, no need since EventTarget was already patched\n\t    if (!_global.EventTarget) {\n\t        utils_1.patchEventTargetMethods(WS.prototype);\n\t    }\n\t    _global.WebSocket = function (a, b) {\n\t        var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);\n\t        var proxySocket;\n\t        // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance\n\t        var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');\n\t        if (onmessageDesc && onmessageDesc.configurable === false) {\n\t            proxySocket = Object.create(socket);\n\t            ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function (propName) {\n\t                proxySocket[propName] = function () {\n\t                    return socket[propName].apply(socket, arguments);\n\t                };\n\t            });\n\t        }\n\t        else {\n\t            // we can patch the real socket\n\t            proxySocket = socket;\n\t        }\n\t        utils_1.patchOnProperties(proxySocket, ['close', 'error', 'message', 'open']);\n\t        return proxySocket;\n\t    };\n\t    for (var prop in WS) {\n\t        _global.WebSocket[prop] = WS[prop];\n\t    }\n\t}\n\texports.apply = apply;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(3);\n\tfunction patchTimer(window, setName, cancelName, nameSuffix) {\n\t    var setNative = null;\n\t    var clearNative = null;\n\t    setName += nameSuffix;\n\t    cancelName += nameSuffix;\n\t    function scheduleTask(task) {\n\t        var data = task.data;\n\t        data.args[0] = task.invoke;\n\t        data.handleId = setNative.apply(window, data.args);\n\t        return task;\n\t    }\n\t    function clearTask(task) {\n\t        return clearNative(task.data.handleId);\n\t    }\n\t    setNative = utils_1.patchMethod(window, setName, function (delegate) { return function (self, args) {\n\t        if (typeof args[0] === 'function') {\n\t            var zone = Zone.current;\n\t            var options = {\n\t                handleId: null,\n\t                isPeriodic: nameSuffix === 'Interval',\n\t                delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 : null,\n\t                args: args\n\t            };\n\t            var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);\n\t            if (!task) {\n\t                return task;\n\t            }\n\t            // Node.js must additionally support the ref and unref functions.\n\t            var handle = task.data.handleId;\n\t            if (handle.ref && handle.unref) {\n\t                task.ref = handle.ref.bind(handle);\n\t                task.unref = handle.unref.bind(handle);\n\t            }\n\t            return task;\n\t        }\n\t        else {\n\t            // cause an error by calling it directly.\n\t            return delegate.apply(window, args);\n\t        }\n\t    }; });\n\t    clearNative = utils_1.patchMethod(window, cancelName, function (delegate) { return function (self, args) {\n\t        var task = args[0];\n\t        if (task && typeof task.type === 'string') {\n\t            if (task.cancelFn && task.data.isPeriodic || task.runCount === 0) {\n\t                // Do not cancel already canceled functions\n\t                task.zone.cancelTask(task);\n\t            }\n\t        }\n\t        else {\n\t            // cause an error by calling it directly.\n\t            delegate.apply(window, args);\n\t        }\n\t    }; });\n\t}\n\texports.patchTimer = patchTimer;\n\n\n/***/ }\n/******/ ]);","// import \"./integration/ES6PromiseHook\" DEPRECATED for the sake of zone.js\r\nimport \"./integration/WatchIterableFix\"\r\n\r\n//Export the angular zone\r\nexport {NgZone} from \"./integration/ZoneJSIntegration\"\r\n\r\n//Export config\r\nexport {config} from \"./util/Configuration\"\r\n\r\n//Export decorators\r\nexport {Controller} from \"./decorators/Controller\"\r\nexport {Service} from \"./decorators/Service\"\r\nexport {Directive} from \"./decorators/Directive\"\r\nexport {Component, Bind} from \"./decorators/Component\"\r\nexport {Filter} from \"./decorators/Filter\"\r\nexport {Config} from \"./decorators/Config\"\r\nexport {Run} from \"./decorators/Run\"\r\nexport {View} from \"./decorators/View\"\r\nexport {Alias} from \"./decorators/Alias\"\r\nexport {Self} from \"./decorators/Self\"\r\nexport {State} from \"./decorators/State\"\r\nexport {Inject} from \"./decorators/Inject\"\r\nexport {Init, Destroy, Watch, WatchCollection, On, Debounce, Schedule, Abstract} from \"./decorators/MethodDecorators\"","import {alias as aliasSymbol} from \"../util/Symbols\"\r\n\r\n/**\r\n * Sets the alias for a controller, can only be used together with @State\r\n * and @Component\r\n * @decorator\r\n */\r\nexport function Alias(alias)\r\n{\r\n    return (target, name) => {\r\n        (target[name] || target)[aliasSymbol] = alias;\r\n        return target;\r\n    }\r\n}\r\n","import {lookupAngularModule as module} from \"../util/AngularModuleResolver\"\r\nimport {decorateView} from \"./View\"\r\nimport * as symbols from \"../util/Symbols\"\r\n\r\n/**\r\n * Defines the class as Component\r\n *\r\n * A component is typically restricted to \"E\" => Element, meaning it will look like\r\n * <component></component> in html.\r\n *\r\n * You can configure the decorator either just with the component selector as string, or\r\n * with a typical angular directive config object, there are some shortcuts available:\r\n *  - controllerAs => as\r\n *  - scope => bind\r\n *  - template => view\r\n *\r\n *  A Component doesn't use the scope, but binds all properties to the controller directly instead.\r\n *\r\n *  If you're using class properties you can use the @Bind([type]) decorator to directly indicate the\r\n *  attributes that should be bound to the outer scope\r\n *\r\n * The @Component decorator can be used together with @View and @Alias and @Bind!\r\n *\r\n * @decorator\r\n * @param conf\r\n * @exports\r\n */\r\nexport function Component(conf = {})\r\n{\r\n    if (conf.constructor == String) {\r\n        conf = { selector : conf };\r\n    }\r\n    conf.controllerAs = conf.as || conf.controllerAs;\r\n    conf.restrict = conf.restrict || \"E\";\r\n    if (conf.bind == false) conf.bind = false;\r\n    else conf.bind = conf.bind || {};\r\n\r\n\r\n    conf.template = conf.view || conf.template;\r\n    conf.selector = conf.name || conf.selector;\r\n\r\n    return target => {\r\n        conf.controller = target;\r\n        module().directive(conf.selector, () => {\r\n\r\n            //Merge @Bind properties\r\n            if (conf.bind !== false) {\r\n                conf.bind = Object.assign(conf.bind || {}, target[symbols.bind] || {});\r\n            }\r\n\r\n            conf.controllerAs = target[symbols.alias] || conf.controllerAs || \"$ctrl\";\r\n            conf.bindToController = conf.bind;\r\n\r\n            decorateView(target, conf);\r\n\r\n            return conf;\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Defines a class property as bound attribute\r\n * @decorator\r\n * @param bindType = or & or @\r\n * @param [attributeName] the name of the attribute, defaults to the property name\r\n * @return {function(*, *, *)}\r\n */\r\nexport function Bind(bindType, attributeName)\r\n{\r\n    return (target, name, desc) => {\r\n\r\n        //Set default attribute name\r\n        if (!attributeName) attributeName = name;\r\n\r\n        //Add the bind property to the type\r\n        let type = target.constructor;\r\n        type[symbols.bind] = type[symbols.bind] || {};\r\n        type[symbols.bind][name] = bindType+attributeName;\r\n\r\n        return {\r\n            writable : true,\r\n            value : desc.value\r\n        };\r\n    }\r\n}","import {lookupAngularModule as module} from \"../util/AngularModuleResolver\"\r\nimport {fetch} from \"../util/AngularUtils\"\r\n\r\n/**\r\n * Defines a method as config block\r\n * @decorator\r\n * @exports\r\n */\r\nexport function Config(target, name) {\r\n    target = fetch(target);\r\n    if (target instanceof Function) module().config(target);\r\n    else module().config(target[name]);\r\n}","import {lookupAngularModule as module} from \"../util/AngularModuleResolver\"\r\nimport {fetch} from \"../util/AngularUtils\"\r\n\r\n/**\r\n * Defines a class as Controller, if no name is provided aka the decorator is\r\n * used as @Controller then the class name is used as controller name, you can\r\n * specify the name by using the decorator like @Controller(\"ControllerName\") to\r\n * make the decorator minify safe\r\n *\r\n * @decorator\r\n * @param {string | function} [clazz]\r\n */\r\nexport function Controller(clazz) {\r\n    clazz = fetch(clazz);\r\n\r\n    //Function to add the controller\r\n    let addController = (name, clazz) => module().controller(name, clazz);\r\n\r\n    if (clazz instanceof Function) {\r\n        addController(clazz.name, clazz);\r\n    }\r\n    else return (target) => {\r\n        addController(clazz, target);\r\n    };\r\n}","import {lookupAngularModule as module} from \"../util/AngularModuleResolver\"\r\nimport {fetch} from \"../util/AngularUtils\"\r\nimport es6enabler from \"../util/ES6Directive\"\r\n\r\n/**\r\n * Defines a class or a class method as Directive, if no name is provided aka the decorator is\r\n * used as @Directive then the class name or the method name is used as directive name, you can\r\n * specify the name by using the decorator like @Directive(\"myDirectiy\") to\r\n * make the decorator minify safe\r\n *\r\n * @decorator\r\n * @param {string | function} clazz\r\n * @param {string} [name]\r\n * @returns {Function}\r\n * @exports\r\n */\r\nexport function Directive(clazz, name) {\r\n    clazz = fetch(clazz);\r\n\r\n    let registerDirective = (name, fn) => module().directive(name, es6enabler(fn));\r\n\r\n    if (clazz.constructor != String) //Directive is called without name => @Directive\r\n    {\r\n        if (clazz instanceof Function) registerDirective(clazz.name, clazz); //Class\r\n        else registerDirective(name, clazz[name]); //Class method\r\n    }\r\n    else return (target, n) => { //Directive is called without name => @Directive(\"myDirective\")\r\n        if (target instanceof Function) registerDirective(clazz, target); //Class\r\n        else registerDirective(n, target[n]); //Class method\r\n    };\r\n}","import {lookupAngularModule as module} from \"../util/AngularModuleResolver\"\r\nimport {fetch} from \"../util/AngularUtils\"\r\n\r\n/**\r\n * REgisters a method as an angular Filter\r\n * If used like @Filter the method name will be chosen as filter name,\r\n * Alternatively you can give the filter name as argument, your method will then look\r\n * like @Filter(\"myFilter\")...\r\n * @decorator\r\n * @exports\r\n */\r\nexport function Filter(clazz, method) {\r\n    clazz = fetch(clazz);\r\n\r\n    //Function to add the controller\r\n    let registerFilter = (name, fn) => module().filter(name, fn);\r\n\r\n    if (clazz.constructor != String) { //With method name as filter name\r\n        registerFilter(method, clazz[method]);\r\n    }\r\n    else return (target, method) => { //With specified name\r\n        registerFilter(clazz, target[method]);\r\n    };\r\n}","import {angularInjector, module} from \"../util/AngularModuleResolver\"\r\nimport * as symbols from \"../util/Symbols\"\r\nimport {callAnnotations} from \"../util/AngularUtils\"\r\n\r\n/**\r\n * Inject one of the following into the object:\r\n *      - services\r\n *      - $scope\r\n *      - any $scope variable\r\n *\r\n * the variable: usage =>\r\n * class foo {\r\n *      @Inject $timeout;\r\n *      @Inject(\"$timeout\") tmout;\r\n *      @Inject fooCtrl\r\n *      @Inject scopeVar\r\n *      @Inject $scope\r\n *\r\n *      constructor()\r\n *      {\r\n *          console.log(this.$timeout, this.tmout);\r\n *      }\r\n * }\r\n *\r\n * Attention! The property won't get injected instantly, but a getter\r\n * which will replace itself with the resolved object on the first call,\r\n * with this technique we're able to resolve circular dependencies sometimes\r\n *\r\n * @param target\r\n * @param name\r\n * @param descriptor\r\n * @decorator\r\n */\r\nexport function Inject(target, name, descriptor)\r\n{\r\n    let fieldName;\r\n    let injector = (target, name, descriptor) =>\r\n    {\r\n        if (descriptor.value instanceof Function) {\r\n            throw new Error(\"Can't use @Inject on a method\");\r\n        }\r\n\r\n        return {\r\n            set : function(value) {\r\n                Object.defineProperty(this, fieldName, {value, writable : true});\r\n            },\r\n            get : function() {\r\n\r\n                let $injector = angularInjector();\r\n                let obj = null;\r\n                let injected = false;\r\n\r\n                let locals = this[symbols.locals] || currentLocals;\r\n\r\n                //Locale\r\n                if (locals && (locals.hasOwnProperty(name) || locals[name])){\r\n                    obj = locals[name];\r\n                    injected = true;\r\n                }\r\n\r\n                //Service\r\n                else if ($injector.has(name)) {\r\n                    obj = $injector.get(name);\r\n                    injected = true;\r\n                }\r\n\r\n                //$scope or parent scope property\r\n                else if (locals && locals.$scope && (Reflect.hasOwnProperty(locals.$scope, name) || locals.$scope[name])){\r\n                    obj = locals.$scope[name];\r\n                    injected = true;\r\n                }\r\n\r\n                if (!injected) {\r\n                    console.error(`Wasn't able to @Inject ${name} as ${fieldName} into ${target.constructor.name}`);\r\n                    return;\r\n                }\r\n\r\n                Object.defineProperty(this, fieldName, {value : obj, writable : true});\r\n                return obj;\r\n            }\r\n        };\r\n    };\r\n\r\n    if (descriptor) {\r\n        fieldName = name;\r\n        return injector(target, name, descriptor);\r\n    }\r\n    else {\r\n        let nameReplacement = target;\r\n        return function(target, name, descriptor) {\r\n            fieldName = name;\r\n            return injector(target, nameReplacement, descriptor);\r\n        };\r\n    }\r\n}\r\n\r\n\r\nlet currentLocals = undefined;\r\nmodule.then(m => m.config([\"$provide\", function($provide){\r\n    $provide.decorator(\"$controller\", [\"$delegate\", function($delegate){\r\n        return function(expression, locals, later, ident){\r\n\r\n            //For usage in constructor\r\n            currentLocals = locals;\r\n\r\n            //Create the controller\r\n            let controller = $delegate(expression, locals, later, ident);\r\n\r\n            //Reset the locals\r\n            currentLocals = undefined;\r\n\r\n            //Check if its an object\r\n            if (!later){\r\n                controller[symbols.locals] = locals;\r\n                controller[symbols.scope] = locals.$scope;\r\n                callAnnotations(controller, locals.$scope);\r\n                return controller;\r\n            }\r\n            else {\r\n                return function(){\r\n                    currentLocals = locals;\r\n                    let c = controller();\r\n                    currentLocals = undefined;\r\n                    c[symbols.locals] = locals;\r\n                    c[symbols.scope] = locals.$scope;\r\n                    callAnnotations(c, locals.$scope);\r\n                    return c;\r\n                }\r\n            }\r\n        };\r\n    }])\r\n}]));\r\n","import {angularInjector} from \"../util/AngularModuleResolver\"\r\nimport * as symbols from \"../util/Symbols\"\r\n\r\n// This file contains the following decorators\r\n// @Init\r\n// @Destroy\r\n// @Watch\r\n// @WatchCollection\r\n// @On\r\n// @Debounce\r\n// @Abstract\r\n\r\n/**\r\n * Executes all Methods annotated with this annotation after\r\n * the object has been created\r\n *\r\n * Only working in services and controllers!\r\n *\r\n * @decorator\r\n */\r\nexport function Init(target, name, descriptor){\r\n    if (!descriptor) {\r\n        throw new Error(\"@Init can only be used on class methods\");\r\n    }\r\n    target[symbols.init] = target[symbols.init] || [];\r\n    target[symbols.init].push(name);\r\n}\r\n\r\n/**\r\n * Executes all Methods annotated with this annotation after\r\n * the object gets destroyed.\r\n *\r\n * Only usable in controllers!\r\n *\r\n * @param target\r\n * @param name\r\n * @exports\r\n * @decorator\r\n */\r\nexport function Destroy(target, name){\r\n    target[symbols.destroy] = target[symbols.destroy] || [];\r\n    target[symbols.destroy].push(name);\r\n}\r\n\r\n/**\r\n * Sets a $watch on the given controller evaluation, the method will be used\r\n * as regular $watch callback.\r\n *\r\n * If your controller has a property \"foo\" the following method would watch for\r\n * changes on \"foo\"\r\n *\r\n * \\@Watch(\"foo\")\r\n * fooChanged(newVal, oldVal)\r\n * {\r\n *  ........\r\n * }\r\n *\r\n * @param property\r\n * @param {boolean} [deep]\r\n * @exports\r\n * @decorator\r\n */\r\nexport function Watch(property, deep = false){\r\n\r\n    return (target, name) => {\r\n        target[symbols.watch] = target[symbols.watch] || [];\r\n        target[symbols.watch].push({property, name, deep, collection : false});\r\n    };\r\n}\r\n\r\n/**\r\n * Same as @Watch but for collections\r\n * @param [property]\r\n * @exports\r\n * @decorator\r\n */\r\nexport function WatchCollection(property){\r\n\r\n    return (target, name) => {\r\n        target[symbols.watch] = target[symbols.watch] || [];\r\n        target[symbols.watch].push({property, name, false, collection : true});\r\n    };\r\n}\r\n\r\n/**\r\n * Schedules the method so it will get executed every n milliseconds\r\n * @param interval in milliseconds\r\n * @decorator\r\n */\r\nexport function Schedule(interval)\r\n{\r\n    return (target, name, desc) => {\r\n        target[symbols.schedule] = target[symbols.schedule] || [];\r\n        target[symbols.schedule].push({interval, name})\r\n    }\r\n}\r\n\r\n/**\r\n * Registers the method as an eventhandler via $scope.$on\r\n *\r\n * \\@On(\"$stateChangeSucces\")\r\n * stateChanged(newState, oldState ...)\r\n * {\r\n *  .......\r\n * }\r\n *\r\n * @param event\r\n * @decorator\r\n */\r\nexport function On(event)\r\n{\r\n    return (target, name, desc) => {\r\n        target[symbols.on] = target[symbols.on] || [];\r\n        target[symbols.on].push({event, name})\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Debounces the method so it will only get executed after it hasn't been called\r\n * for n millis\r\n *\r\n * @param millis\r\n * @param {boolean} [angularTimeout=true] - if false the window timeout will get used\r\n * @returns {Function}\r\n * @decorator\r\n */\r\nexport function Debounce(millis, angularTimeout = true)\r\n{\r\n    return (target, name, desc) => {\r\n        let timeout;\r\n        let fn = desc.value;\r\n        desc.value = function(...args){\r\n\r\n            //Setup\r\n            let context = this;\r\n            let timeoutFn = function(){\r\n                fn.apply(context,args);\r\n            };\r\n\r\n            //Use angular $timeout ($apply cycle)\r\n            if (angularTimeout)\r\n            {\r\n                let $timeout = angularInjector().get(\"$timeout\");\r\n                $timeout.cancel(timeout);\r\n                timeout = $timeout(timeoutFn, millis);\r\n            }\r\n            //Use window timeout\r\n            else\r\n            {\r\n                clearTimeout(timeout);\r\n                timeout = setTimeout(timeoutFn, millis);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Marks a method as abstract, this means the method will get replaced\r\n * with one that throws an error when called saying the method\r\n * is not implemented\r\n * @param target\r\n * @param name\r\n * @param desc\r\n * @decorator\r\n */\r\nexport function Abstract(target, name, desc)\r\n{\r\n    desc.value = function(){\r\n        throw new Error(`${target.name}@${name} is not implemented (Abstract)`);\r\n    };\r\n}","import {lookupAngularModule as module} from \"../util/AngularModuleResolver\"\r\nimport {fetch} from \"../util/AngularUtils\"\r\n\r\n/**\r\n * Defines a method as run block\r\n * @decorator\r\n * @exports\r\n */\r\nexport function Run(target, name) {\r\n    target = fetch(target);\r\n    if (target instanceof Function) module().run(target);\r\n    else module().run(target[name]);\r\n}","/**\r\n * The decorator may be used on classes or methods\r\n * ```\r\n * @Self\r\n * class FullBound {}\r\n *\r\n * class PartBound {\r\n *   @Self\r\n *   method () {}\r\n * }\r\n * ```\r\n *\r\n * @decorator\r\n */\r\nexport function Self(...args) {\r\n    if (args.length === 1) {\r\n        return boundClass(...args);\r\n    } else {\r\n        return boundMethod(...args);\r\n    }\r\n}\r\n\r\n/**\r\n * Use boundMethod to bind all methods on the target.prototype\r\n */\r\nfunction boundClass(target) {\r\n    // (Using reflect to get all keys including symbols)\r\n    let keys;\r\n    // Use Reflect if exists\r\n    if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\r\n        keys = Reflect.ownKeys(target.prototype);\r\n    } else {\r\n        keys = Object.getOwnPropertyNames(target.prototype);\r\n        // use symbols if support is provided\r\n        if (typeof Object.getOwnPropertySymbols === 'function') {\r\n            keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\r\n        }\r\n    }\r\n\r\n    keys.forEach(key => {\r\n        // Ignore special case target method\r\n        if (key === 'constructor') {\r\n            return;\r\n        }\r\n\r\n        let descriptor = Object.getOwnPropertyDescriptor(target.prototype, key);\r\n\r\n        // Only methods need binding\r\n        if (typeof descriptor.value === 'function') {\r\n            Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\r\n        }\r\n    });\r\n    return target;\r\n}\r\n\r\n/**\r\n * Return a descriptor removing the value and returning a getter\r\n * The getter will return a .bind version of the function\r\n * and memoize the result against a symbol on the instance\r\n */\r\nfunction boundMethod(target, key, descriptor) {\r\n    let fn = descriptor.value;\r\n\r\n    if (typeof fn !== 'function') {\r\n        throw new Error(`@Self decorator can only be applied to methods not: ${typeof fn}`);\r\n    }\r\n\r\n    return {\r\n        configurable: true,\r\n        get : function() {\r\n            let self = this;\r\n            return (...params) => fn.call(self, ...params);\r\n        }\r\n    };\r\n}","import {lookupAngularModule as module} from \"../util/AngularModuleResolver\"\r\nimport {fetch} from \"../util/AngularUtils\"\r\n\r\n/**\r\n * Defines a class as Service, if no name is provided aka the decorator is\r\n * used as @Service then the class name is used as service name, you can\r\n * specify the name by using the decorator like @Service(\"ServiceName\") to\r\n * make the decorator minify safe\r\n *\r\n * @decorator\r\n * @param {string | function} [clazz]\r\n */\r\nexport function Service(clazz) {\r\n    clazz = fetch(clazz);\r\n\r\n    //Function to add the controller\r\n    let addService = (name, clazz) => module().service(name, clazz);\r\n\r\n    if (clazz instanceof Function) {\r\n        addService(clazz.name, clazz);\r\n    }\r\n    else return (target) => {\r\n        addService(clazz, target);\r\n    };\r\n}","import {Controller} from \"./Controller\"\r\nimport {module} from \"../util/AngularModuleResolver\"\r\nimport {decorateView} from \"./View\"\r\nimport {config} from \"../util/Configuration\"\r\nimport * as symbols from \"../util/Symbols\"\r\n\r\n/**\r\n * Angular UI Router support\r\n *\r\n * With this Decorator you are able to decorate any class with @State,\r\n * as parameter you will give the usual state config\r\n *\r\n * In addition you can specify a default state by adding default : true\r\n * to the state config, this state will be called when a 404 aka a missing\r\n * url is requested. You're also able to shorten controllerAS to as.\r\n *\r\n * The class which is being decorated with @State will work as controller\r\n * for the specified state\r\n *\r\n * The State decorator works best with @Alias and @View\r\n *\r\n * @decorator\r\n * @param conf\r\n * @returns {Function}\r\n * @exports\r\n */\r\nexport function State(conf)\r\n{\r\n    return target => {\r\n        target[symbols.state] = conf;\r\n        Controller(target);\r\n        return target;\r\n    }\r\n}\r\n\r\n/**\r\n * Tries to configure the state from the $$state var on\r\n * the all controllers\r\n * @param clazz\r\n */\r\nmodule.then( m => {\r\n    m.config([\"$injector\", function ($injector) {\r\n        \"ngInject\";\r\n\r\n        let registeredControllers = [];\r\n        let states = [];\r\n\r\n        //Find every state controller\r\n        m._invokeQueue.forEach(item => {\r\n            let constructor = item[2][1];\r\n            if (registeredControllers.find((t) => t.type == constructor)) return;\r\n            if (constructor[symbols.state]) {\r\n                constructor[symbols.state].clazz = constructor;\r\n                states.push(constructor[symbols.state]);\r\n                registeredControllers.push({type: constructor});\r\n            }\r\n        });\r\n\r\n        //Return if ui-router is not installed\r\n        if (!$injector.has(\"$stateProvider\")) {\r\n\r\n            if (states.length) {\r\n                console.error(\"Error: @State is used but ui-router is not installed!\")\r\n            }\r\n            return;\r\n        }\r\n\r\n        //Fetch the state provider\r\n        let $stateProvider = $injector.get(\"$stateProvider\");\r\n        let $urlRouterProvider = $injector.get(\"$urlRouterProvider\");\r\n\r\n        //Indicator if a default state has been set\r\n        let defaultState = false;\r\n\r\n        //Configure all states\r\n        for (let conf of states) {\r\n            let clazz = conf.clazz;\r\n\r\n            //Set the default state if\r\n            if (conf.default) {\r\n                if (defaultState) {\r\n                    throw new Error(`Default state has already been set while configuring ${conf.name}, other default: ${defaultState.name}`);\r\n                }\r\n                defaultState = conf;\r\n                $urlRouterProvider.otherwise(function ($injector) {\r\n                    $injector.invoke(['$state', function ($state) {\r\n                        $state.go(conf.name, {}, {location: \"replace\"});\r\n                    }]);\r\n                });\r\n            }\r\n\r\n            //Set the controller\r\n            conf.controller = clazz;\r\n            conf.controllerAs = conf.as || conf.controllerAs || clazz[symbols.alias];\r\n\r\n            //Attempt to decorate @View decorator\r\n            decorateView(clazz, conf);\r\n\r\n            //Apply decorators\r\n            let decoratedConf = config.STATE_DECORATOR(conf);\r\n            if (decoratedConf) conf = decoratedConf;\r\n\r\n            //Finally configure the state onto the ui-router\r\n            $stateProvider.state(conf);\r\n        }\r\n    }]);\r\n});","import * as symbols from \"../util/Symbols\"\r\n\r\n/**\r\n * Sets the view of an @Component or a @State can either be\r\n * a template or a templateUrl, the view is recognized as template\r\n * if it contains at least 1 tag!\r\n * @param view\r\n * @Decorator\r\n */\r\nexport function View(view)\r\n{\r\n    return (target) => {\r\n        target[symbols.view] = view;\r\n        return target;\r\n    }\r\n}\r\n\r\n/**\r\n * Decorates the view to the configuration\r\n * @param clazz\r\n * @param conf\r\n */\r\nexport function decorateView(clazz, conf)\r\n{\r\n    let view = clazz[symbols.view];\r\n    if (!view) return;\r\n    let urlRegex = /[^<>]+\\.[A-Za-z]{2,5}$/;\r\n    if (urlRegex.test(\r\n        view)) { //url\r\n        conf.templateUrl = view;\r\n    } else {\r\n        conf.template = view;\r\n    }\r\n}","import {module} from \"../util/AngularModuleResolver\"\r\n\r\n/**\r\n * This module targets angulars missing ability to track objects following the ES6 iterator pattern,\r\n * where any object which has a [Symbol.iterator]() method is iterable.\r\n *\r\n * This module monkey patches every $scope to proxy $watchCollection and transform a possible iterable\r\n * into a simple array.\r\n *\r\n * If you want to access the original methods, you will have to call $scope[Symbol.for(\"$watchCollection\")]\r\n */\r\nmodule.then(module => {\r\n    /**\r\n     * Hook into the $rootScopeProvider to make sure we're the first ones to modify the $rootScope\r\n     */\r\n    module.config([\"$rootScopeProvider\", function($rootScopeProvider){\r\n        const $get = $rootScopeProvider.$get;\r\n        $rootScopeProvider.$get = [\"$injector\", \"$parse\", function($injector, $parse){\r\n            let $rootScope = $injector.invoke($get);\r\n\r\n            monkeyPatch$watchCollection($rootScope, $parse);\r\n            monkeyPatch$watchCollection($rootScope.__proto__.constructor.prototype, $parse);\r\n\r\n            return $rootScope;\r\n        }];\r\n    }]);\r\n});\r\n\r\n/**\r\n * Global symbols to access the\r\n * @type {Symbol}\r\n * @private\r\n */\r\nconst $watchCollection = Symbol.for(\"$watchCollection\");\r\n\r\n\r\n/**\r\n * Here we're actually patching the $watchCollection method\r\n * @param $target\r\n * @param $parse\r\n */\r\nfunction monkeyPatch$watchCollection($target, $parse)\r\n{\r\n    $target[$watchCollection] = $target.$watchCollection;\r\n\r\n    $target.$watchCollection = function(property, action){\r\n\r\n        let isFunc = typeof property == 'function';\r\n        let getter = isFunc ? property : $parse(property);\r\n        let iterableAsArray = undefined;\r\n        let $scope = this;\r\n\r\n        let monkeyPatchedObserver = function(){\r\n            let resolved = getter(isFunc ? undefined : $scope);\r\n\r\n            if (resolved && !(resolved instanceof Array) && resolved[Symbol.iterator])\r\n            {\r\n                //Reference changed, change our too\r\n                if (resolved !== iterableAsArray) {\r\n                    iterableAsArray = [];\r\n                }\r\n\r\n                //Refill array\r\n                iterableAsArray.length = 0;\r\n                for (let item of resolved) {\r\n                    iterableAsArray.push(item);\r\n                }\r\n\r\n                //And return it as result of the watch expression\r\n                return iterableAsArray;\r\n            }\r\n            iterableAsArray = undefined;\r\n\r\n            //If it's not an iterable non-array just return the original object\r\n            return resolved;\r\n        };\r\n\r\n        return this[$watchCollection](monkeyPatchedObserver, action); //Must be this way because of maximum call stack size exceeded error\r\n    }\r\n}","import \"zone.js\"\r\n\r\n//The default zone where runOutsideAngular() calls are being executed\r\nconst outerZone = Zone.current;\r\n\r\n//Create the angular zone\r\nexport const NgZone = outerZone.fork({\r\n    name : \"Angular Zone <ng-next>\",\r\n    onInvoke : function(delegate, current, target, callback, applyThis, args) {\r\n        try {\r\n            NgZone.$digested = false;\r\n            return delegate.invoke(target, callback, applyThis, args);\r\n        } finally {\r\n            $digestOnce();\r\n        }\r\n    },\r\n    onInvokeTask : function(delegate, current, target, task, applyThis, args) {\r\n        try {\r\n            NgZone.$digested = false;\r\n            return delegate.invokeTask(target, task, applyThis, args);\r\n        } finally {\r\n            $digestOnce();\r\n        }\r\n    }\r\n});\r\n\r\n// Add $digest to the zone\r\nNgZone.$digest = function(){};\r\n\r\n// Digests only if not already done\r\nconst $digestOnce = function () {\r\n    if (!NgZone.$digested) NgZone.$digest();\r\n    NgZone.$digested = false;\r\n};\r\n\r\n// Add runOutsideAngular to the zone\r\nNgZone.runOutsideAngular = function (fn) {\r\n    outerZone.run(fn);\r\n};\r\n\r\n//NgZone module\r\nexport const ngZoneModule = angular.module(\"ngZone\", []);\r\nngZoneModule.factory(\"NgZone\", () => NgZone);\r\n\r\n//Add auto-bootstrap handler\r\nangular.element(document).ready(() => {\r\n\r\n    NgZone.run(() => {\r\n\r\n        //Export the angular zone onto the window if not existing\r\n        window.NgZone = window.NgZone || NgZone;\r\n\r\n        //Resume bootstrap inside of our angular zone\r\n       angular.resumeBootstrap([\"ngZone\"]).invoke([\"$rootScope\", ($rootScope) => {\r\n\r\n           //Patch root scopes digest to set an indicator on the zone\r\n           const digestSymbol = Symbol.for(\"$digest\");\r\n           $rootScope[digestSymbol] = $rootScope.$digest;\r\n\r\n           //If you want to digest on zone leave give \"false\" as parameter to $rootScope.$digest\r\n           $rootScope.$digest = function (disableZoneJS = true) {\r\n               if (disableZoneJS) NgZone.$digested = true;\r\n               this[digestSymbol]();\r\n           };\r\n\r\n           //Add digest to the angular zone\r\n           NgZone.$digest = function(){\r\n               $rootScope.$digest();\r\n           }\r\n\r\n       }]);\r\n    });\r\n});\r\n\r\n//Force angular to stop the bootstrap process\r\nwindow.name = \"NG_DEFER_BOOTSTRAP!\";\r\n","import {config} from \"./Configuration\"\r\n\r\n/**\r\n * Reference to the angular module used by Angular2to1, this module is either\r\n * resolved via ng-app or by useAngularModule(...)\r\n */\r\nlet angularModule = null;\r\n\r\n/**\r\n * The injector of our main module\r\n * This $injector service is set as soon as the module was requested\r\n * the first time and angular is beyond its run phase\r\n */\r\nlet $injector = null;\r\nlet $injectorRequested = false;\r\n\r\nlet requestInjector = function(){\r\n    if (angularModule && !$injectorRequested)\r\n    {\r\n        angularModule.run([\"$injector\", i => $injector = i]);\r\n        $injectorRequested = true;\r\n    }\r\n};\r\n\r\n/**\r\n * Attempts to lookup the root angular module of the app by resolving the first\r\n * ng-app on the DOM\r\n * As an alternative you can set your module with useAngularModule(), which will\r\n * then be returned by this function\r\n */\r\nexport function lookupAngularModule()\r\n{\r\n    try {\r\n        //Get manually specified module from config\r\n        if (config.MODULE && !angularModule) {\r\n            angularModule = config.MODULE;\r\n        }\r\n\r\n        //Returns the preset module if available\r\n        if (angularModule) {\r\n            return angularModule;\r\n        }\r\n\r\n        let ngAppHolder = angular.element(document.querySelector(\"[ng-app]\"));\r\n\r\n\r\n        if (!ngAppHolder.length) {\r\n            throw new Error(\"No element with [ng-app] found and no module set with 'useAngularModule()'\");\r\n        }\r\n\r\n        let moduleName = ngAppHolder[0].getAttribute('ng-app');\r\n        angularModule = angular.module(moduleName);\r\n\r\n        return angularModule;\r\n    } finally {\r\n        requestInjector();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Sets the angular module which is used by Angular2to1\r\n * @param module\r\n */\r\nexport function useAngularModule(module)\r\n{\r\n    angularModule = module;\r\n    requestInjector();\r\n}\r\n\r\n/**\r\n * Returns the main $injector of the root angular\r\n * module, is available as soon as the module has been requested at least\r\n * once and angular is beyond its run phase\r\n * @decorator\r\n * @return {*}\r\n */\r\nexport function angularInjector()\r\n{\r\n    return $injector;\r\n}\r\n\r\n\r\nconst modulePromise = new Promise(function (resolve) {\r\n    try  //If we're lucky the module does already exist\r\n    {\r\n        let module = lookupAngularModule();\r\n        resolve(module);\r\n    }\r\n    catch (e) //Otherwise we must attempt to await its creation\r\n    {\r\n        /**\r\n         * If ng-app is defined we're monkey patching angulars module() function\r\n         * in order to get notified as soon as the module is available\r\n         * @type {Object}\r\n         */\r\n        let ngAppHolder = angular.element(document.querySelector(\"[ng-app]\"));\r\n        if (ngAppHolder.length)\r\n        {\r\n            let appModuleName = ngAppHolder[0].getAttribute('ng-app');\r\n            const origModuleFunction = angular.module;\r\n\r\n            if (!angular) {\r\n                throw new Error(\"Please include angular before ng-next!\");\r\n            }\r\n\r\n            //Monkey patch the module function to detect its creation\r\n            angular.module = function(name, dependencies)\r\n            {\r\n                let module = origModuleFunction(name, dependencies);\r\n\r\n                //Our main module is available\r\n                if (name == appModuleName && dependencies) {\r\n                    angular.module = origModuleFunction;\r\n                    resolve(module);\r\n                }\r\n\r\n                return module;\r\n            };\r\n        } else {\r\n            //In case no ng-app is available we must monkey patch the config object to get\r\n            //Notified when the module is getting configured\r\n            let moduleSymbol = Symbol(\"MODULE\");\r\n            Object.defineProperty(config, \"MODULE\", {\r\n                set : module => {\r\n                    if (!config[moduleSymbol]) {\r\n                        resolve(module);\r\n                    }\r\n                    config[moduleSymbol] = module\r\n                },\r\n                get : () => config[moduleSymbol]\r\n            })\r\n        }\r\n\r\n    }\r\n});\r\n\r\nexport {modulePromise as module}\r\n","import {angularInjector, module} from \"./AngularModuleResolver\"\r\nimport {config} from \"./Configuration\"\r\nimport * as symbols from \"../util/Symbols\"\r\n\r\n/**\r\n * If the argument is an array (inject) this method\r\n * will return only the function with the $inject property\r\n * set\r\n * @param arg\r\n * @returns {Function}\r\n */\r\nexport function fetch(arg)\r\n{\r\n    if (arg.constructor == Array)\r\n    {\r\n        let arr = arg;\r\n        arg = arr.splice(arr.length - 1, 1)[0];\r\n        arg.$inject = arr;\r\n    }\r\n    return arg;\r\n}\r\n\r\n// Run block which will configure all annotations on any services available\r\n// All services are used together with the $rootScope\r\n/**\r\n * Exposes all services of a single module\r\n * @param module\r\n */\r\nlet exposeModule = module => {\r\n    let $injector = angularInjector();\r\n    let $rootScope = $injector.get(\"$rootScope\");\r\n    module._invokeQueue.forEach(item => {\r\n        let def = item[2];\r\n        if ($injector.has(def[0])) {\r\n            let service = $injector.get(def[0]);\r\n            callAnnotations(service, $rootScope);\r\n        }\r\n    });\r\n};\r\n\r\n//Await the angular module\r\nmodule.then(m => {\r\n    m.run(() => {\r\n        if (config.ALLOW_DECORATORS_IN_SERVICES) {\r\n            exposeModule(m)\r\n        }\r\n    });\r\n});\r\n\r\n/**\r\n * Calls all registered annotations on the controller, or on\r\n * a service\r\n * @param controller\r\n * @param $scope\r\n */\r\nexport function callAnnotations(controller, $scope)\r\n{\r\n    //Async wrapper\r\n    let asyncWrapper = function (result) {\r\n        if (result instanceof Promise) {\r\n            result.then(() => $scope.$digest.call($scope));\r\n        }\r\n    };\r\n\r\n    //Call init methods\r\n    let inited = [];\r\n    for (let initializer of controller[symbols.init] || [])\r\n    {\r\n        if (!inited.includes(initializer)) {\r\n            asyncWrapper(controller[initializer]());\r\n        }\r\n        inited.push(initializer);\r\n    }\r\n\r\n    //Bind watches\r\n    let watched = [];\r\n    let $parse = angularInjector().get(\"$parse\");\r\n    for (let watcher of controller[symbols.watch] || []) {\r\n        if (!watched.includes(watcher)) {\r\n\r\n            //Parse the angular expression\r\n            let parse = $parse(watcher.property);\r\n            let getter = () => parse(controller);\r\n\r\n            let action = function(...params){\r\n                controller[watcher.name](...params);\r\n            }.bind(controller);\r\n\r\n            if (!watcher.collection) $scope.$watch(getter, action, !!watcher.deep);\r\n            else $scope.$watchCollection(getter, action);\r\n        }\r\n        watched.push(watcher);\r\n    }\r\n\r\n\r\n    //Bind events\r\n    let evented = [];\r\n    for (let on of controller[symbols.on] || []) {\r\n        if (! evented.includes(on)) {\r\n            $scope.$on(on.event, function(...params){\r\n                asyncWrapper(controller[on.name](...params));\r\n            }).bind(controller);\r\n        }\r\n        evented.push(on);\r\n    }\r\n\r\n    //Scheduled methods\r\n    let $interval = angularInjector().get(\"$interval\");\r\n    let scheduled = [];\r\n    for (let schedule of controller[symbols.schedule] || []) {\r\n        if (!scheduled.includes(schedule)){\r\n            let id = $interval(function(){\r\n                asyncWrapper(controller[schedule.name]());\r\n            }.bind(controller), schedule.interval);\r\n            $scope.$on(\"$destroy\", () => $interval.cancel(id));\r\n        }\r\n    }\r\n\r\n    //Call destroy methods\r\n    $scope.$on(\"$destroy\", function(){\r\n        let destroyed = [];\r\n        for (let destroyer of controller[symbols.destroy] || [])\r\n        {\r\n            if (!destroyed.includes(destroyer)) controller[destroyer]();\r\n            destroyed.push(destroyer);\r\n        }\r\n    });\r\n}","// The purpose of this file is to provide an easy configuration API\r\n// accesible from the outside\r\n\r\n/**\r\n * The module configuration, as an anonymous object\r\n */\r\nconst NgNextConfig =  {\r\n    //Angular module\r\n    MODULE : undefined,\r\n\r\n    /**\r\n     * @deprecated since zone.js integration is used for change detection\r\n     */\r\n    DEBOUNCE_DIGEST_MILLIS : false,\r\n\r\n    /**\r\n     * @deprecated since zone.js integration is used for change detection\r\n     */\r\n    ASYNC_AWAIT_ENABLED : false,\r\n\r\n    //Further configuration\r\n    ALLOW_DECORATORS_IN_SERVICES : true,\r\n\r\n    //Decorators\r\n    STATE_DECORATOR : state => state\r\n};\r\n\r\nexport {NgNextConfig as config};","/**\r\n * This wrapper enables an intuitive way to use of es6 classes\r\n * as angular directive.\r\n * If you wrap your directive class with this function you can\r\n * use link/compile functions with \"this\" reference and @ngInject\r\n * on both the constructor and the controller!\r\n *\r\n * @param directive\r\n */\r\nexport default function(directive)\r\n{\r\n    /**\r\n     * Fetch function from array\r\n     */\r\n    if (directive.constructor == Array)\r\n    {\r\n        let arr = directive;\r\n        directive = arr.splice(arr.length - 1, 1)[0];\r\n        directive.$inject = arr;\r\n    }\r\n\r\n    //Check if directive is an actual class\r\n    try\r\n    {\r\n        directive();\r\n        return directive;\r\n    }\r\n    catch (e)\r\n    {\r\n        //Continue and wrap class to make it usable in angular\r\n        if(!(e instanceof TypeError)) return directive;\r\n    }\r\n\r\n    let fn = function(...inject)\r\n    {\r\n        //Create Directive\r\n        let instance = new directive(...inject);\r\n\r\n        //Wrap link call to keep this references\r\n        if (!!instance.link)\r\n        {\r\n            let link = instance.link;\r\n\r\n            instance.link = function(...args){\r\n                link.apply(instance, args);\r\n            };\r\n        }\r\n\r\n        //Wrap compile call to keep \"this\" reference\r\n        if (!!instance.compile)\r\n        {\r\n            let compile = instance.compile;\r\n\r\n            instance.compile = function(...args)\r\n            {\r\n                return compile.apply(instance, args);\r\n            }\r\n        }\r\n\r\n        //Return the directive to angular\r\n        return instance;\r\n    };\r\n\r\n    //Keep ngAnnotate injects\r\n    fn.$inject = directive.$inject;\r\n\r\n    return fn;\r\n};","export const state = Symbol(\"@State\");\r\nexport const view = Symbol(\"@View\");\r\nexport const alias = Symbol(\"@Alias\");\r\nexport const init = Symbol(\"@Init\");\r\nexport const destroy = Symbol(\"@Destroy\");\r\nexport const watch = Symbol(\"@Watch\");\r\nexport const on = Symbol(\"@On\");\r\nexport const schedule = Symbol(\"@Schedule\");\r\nexport const bind = Symbol(\"@Bind\");\r\nexport const scope = Symbol(\"Scope\");\r\nexport const locals = Symbol(\"Locals\");\r\n"]}